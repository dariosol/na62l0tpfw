
monitor.elf:     file format elf32-littlenios2
monitor.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002020

Program Header:
    LOAD off    0x00000074 vaddr 0x00002000 paddr 0x00002000 align 2**0
         filesz 0x00001564 memsz 0x00001564 flags r-x
    LOAD off    0x000015d8 vaddr 0x00003564 paddr 0x00003564 align 2**0
         filesz 0x00000018 memsz 0x00000120 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00000074  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00002020  00002020  000015f0  2**0
                  CONTENTS
  2 .text         000013fc  00002020  00002020  00000094  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000148  0000341c  0000341c  00001490  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000018  00003564  00003564  000015d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000108  0000357c  0000357c  000015f0  2**2
                  ALLOC, SMALL_DATA
  6 .mem          00000000  00003684  00003684  000015f0  2**0
                  CONTENTS
  7 .comment      000002ec  00000000  00000000  000015f0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000208  00000000  00000000  000018e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000527  00000000  00000000  00001ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000019ae  00000000  00000000  0000200f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00000c0d  00000000  00000000  000039bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00003ae3  00000000  00000000  000045ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  0000046c  00000000  00000000  000080b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000008e2  00000000  00000000  0000851c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00008e00  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .cpu          00000003  00000000  00000000  0000a308  2**0
                  CONTENTS, READONLY
 17 .simulation_enabled 00000001  00000000  00000000  0000a30b  2**0
                  CONTENTS, READONLY
 18 .stderr_dev   00000009  00000000  00000000  0000a30c  2**0
                  CONTENTS, READONLY
 19 .stdin_dev    00000009  00000000  00000000  0000a315  2**0
                  CONTENTS, READONLY
 20 .stdout_dev   00000009  00000000  00000000  0000a31e  2**0
                  CONTENTS, READONLY
 21 .sopc_system_name 00000004  00000000  00000000  0000a327  2**0
                  CONTENTS, READONLY
 22 .quartus_project_dir 00000020  00000000  00000000  0000a32b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 
00002020 l    d  .exceptions	00000000 
00002020 l    d  .text	00000000 
0000341c l    d  .rodata	00000000 
00003564 l    d  .rwdata	00000000 
0000357c l    d  .bss	00000000 
00003684 l    d  .mem	00000000 
00000000 l    d  .comment	00000000 
00000000 l    d  .debug_aranges	00000000 
00000000 l    d  .debug_pubnames	00000000 
00000000 l    d  .debug_info	00000000 
00000000 l    d  .debug_abbrev	00000000 
00000000 l    d  .debug_line	00000000 
00000000 l    d  .debug_frame	00000000 
00000000 l    d  .debug_str	00000000 
00000000 l    d  .debug_alt_sim_info	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    d  *ABS*	00000000 
00000000 l    df *ABS*	00000000 c:/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp/HAL/src/crt0.S
00000000 l    df *ABS*	00000000 ./HAL/inc/sys/alt_log_printf.h
00000000 l    df *ABS*	00000000 ./system.h
00000000 l    df *ABS*	00000000 ./HAL/inc/sys/alt_log_printf.h
00000000 l    df *ABS*	00000000 c:/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp/HAL/src/crt0.S
00000000 l    df *ABS*	00000000 ./HAL/inc/nios2.h
00000000 l    df *ABS*	00000000 c:/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp/HAL/src/crt0.S
00000000 l    df *ABS*	00000000 ./system.h
00000000 l    df *ABS*	00000000 ./linker.h
00000000 l    df *ABS*	00000000 ./system.h
00000000 l    df *ABS*	00000000 c:/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp/HAL/src/crt0.S
00000000 l    df *ABS*	00000000 <command line>
00000000 l    df *ABS*	00000000 <built-in>
00000000 l    df *ABS*	00000000 /cygdrive/c/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp//
00000000 l    df *ABS*	00000000 c:/Stefano/PCIe-new/src/mac/sopc/software/monitor_bsp/HAL/src/crt0.S
00002054 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_getch_jtag_uart.c
00000000 l    df *ABS*	00000000 alt_getch_rs232_uart.c
000035f4 l     O .bss	00000040 rxbuffer.0
0000357c l     O .bss	00000004 rdptr.1
00003580 l     O .bss	00000004 wrptr.2
00003584 l     O .bss	00000004 rxbuflen.3
00000000 l    df *ABS*	00000000 alt_putch_jtag_uart.c
00000000 l    df *ABS*	00000000 alt_putch_rs232_uart.c
00000000 l    df *ABS*	00000000 alt_putstr_jtag_uart.c
00000000 l    df *ABS*	00000000 alt_putstr_rs232_uart.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00003588 l     O .bss	00000004 timeout.0
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0000358c l     O .bss	00000004 timeout.0
00000000 l    df *ABS*	00000000 monitor.c
00003634 l     O .bss	00000020 buf.5
00003590 l     O .bss	00000004 buflen.6
00003594 l     O .bss	00000004 wrindex.7
00003598 l     O .bss	00000004 rdindex.8
0000359c l     O .bss	00000004 flagfull.9
00003654 l     O .bss	00000020 buf.0
000035a0 l     O .bss	00000004 buflen.1
000035a4 l     O .bss	00000004 wrindex.2
000035a8 l     O .bss	00000004 rdindex.3
000035ac l     O .bss	00000004 flagfull.4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
00000000 l    df *ABS*	00000000 int_errno.c
0000295c g     F .text	000000f4 rs232_uart_getch
000032e4 g     F .text	00000034 alt_main
000035c0 g     O .bss	00000004 dat
000035c4 g     O .bss	00000004 rdata
00002d84 g     F .text	000000f8 cmdwrite
00003574 g     O .rwdata	00000004 jtag_uart
00000000  w      *UND*	00000000 __errno
00002000 g     F .entry	0000000c __reset
000035f0 g     O .bss	00000004 errno
00003568 g     O .rwdata	00000004 alt_argv
0000b564 g       *ABS*	00000000 _gp
0000221c g     F .text	00000088 alt_putch_rs232_uart
000035bc g     O .bss	00000004 narg
00002174 g     F .text	00000088 alt_putch_jtag_uart
00003414 g     F .text	00000008 altera_nios2_irq_init
00002fe4 g     F .text	00000114 cmdexec
000022c4 g     F .text	000000a8 alt_putstr_jtag_uart
0000333c g     F .text	00000060 altera_avalon_jtag_uart_read
00002880 g     F .text	000000dc jtag_uart_getch
00003570 g     O .rwdata	00000004 rs232_uart
000035dc g     O .bss	00000004 echo_eth
000035d0 g     O .bss	00000004 jtag_uart_ready
00002c9c g     F .text	000000e8 cmdread
00003684 g       *ABS*	00000000 __bss_end
000035d4 g     O .bss	00000004 rs232_uart_ready
00002e7c g     F .text	00000110 cmdecho
00002578 g     F .text	000000e8 cmdinit
000035c8 g     O .bss	00000004 cmd0
00002000 g       *ABS*	00000000 __alt_mem_mem
00003674 g     O .bss	00000010 arg
000035d8 g     O .bss	00000004 echo_flag
00002570 g     F .text	00000008 R4
000035e4 g     O .bss	00000004 echo_port
00002c24 g     F .text	00000020 msnibble
00003684 g       *ABS*	00000000 end
00002480 g     F .text	0000006c altera_avalon_uart_write
00004000 g       *ABS*	00000000 __alt_stack_pointer
00002414 g     F .text	0000006c altera_avalon_jtag_uart_write
000024ec g     F .text	00000034 wait
00002020 g     F .text	00000038 _start
00003338 g     F .text	00000004 alt_sys_init
00002520 g     F .text	00000050 W4
000032bc g     F .text	00000028 __mulsi3
00002bb0 g     F .text	00000074 output_send
00002ae0 g     F .text	000000d0 output_putstr
00003684 g       *ABS*	00000000 __alt_stack_base
00002660 g     F .text	00000010 idle_function
000022a4 g     F .text	00000020 alt_test_rs232_uart
0000357c g       *ABS*	00000000 __bss_start
000030f8 g     F .text	000001c4 main
000035b4 g     O .bss	00000004 sts
00003564 g     O .rwdata	00000004 alt_envp
00002718 g     F .text	00000054 eth_putchar
000021fc g     F .text	00000020 alt_test_jtag_uart
00003578 g     O .rwdata	00000004 alt_errno
00003318 g     F .text	00000020 alt_irq_init
00002c44 g     F .text	00000058 printhex
0000356c g     O .rwdata	00000004 alt_argc
000035e0 g     O .bss	00000004 echo_addr
00002f8c g     F .text	00000058 header
00002670 g     F .text	000000a8 eth_getch
0000357c g       *ABS*	00000000 _edata
00003684 g       *ABS*	00000000 _end
0000236c g     F .text	000000a8 alt_putstr_rs232_uart
000020a0 g     F .text	000000d4 alt_getch_rs232_uart
000035ec g     O .bss	00000004 eth_srcport
0000200c g       .entry	00000000 exit
0000276c g     F .text	00000078 eth_putstr
000035b8 g     O .bss	00000004 argflag
00004000 g       *ABS*	00000000 __alt_data_end
0000200c g       .entry	00000000 _exit
0000339c g     F .text	00000078 altera_avalon_uart_read
000035e8 g     O .bss	00000004 eth_srcaddr
000027e4 g     F .text	0000009c eth_send
000035b0 g     O .bss	00000004 io_stream
000035cc g     O .bss	00000004 cmd1
00002a50 g     F .text	00000090 output_putchar
00002058 g     F .text	00000048 alt_getch_jtag_uart


Disassembly of section .entry:

00002000 <__reset>:
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2004:	08480814 	ori	at,at,8224
    jmp r1
    2008:	0800683a 	jmp	at

0000200c <_exit>:
	...
Disassembly of section .text:

00002020 <_start>:

    .size __reset, . - __reset
#endif /* Jump to _start */

/*
 * When not using exit, provide an _exit symbol to prevent unresolved
 * references to _exit from the linker script.
 */
#ifdef ALT_NO_EXIT
    .globl _exit
_exit:
#endif

/*************************************************************************\
|                          TEXT SECTION (.text)                           |
\*************************************************************************/

/*
 * Start of the .text section, and also the code entry point when
 * the code is executed by a bootloader rather than directly from reset.
 */
    .section .text
    .align 2

    .globl _start
    .type _start, @function
_start:

/*
 * Initialize the data cache if present (i.e. size > 0) and not
 * optimizing for RTL simulation.
 * RTL simulations can ensure the data cache is already initialized
 * so skipping this loop speeds up RTL simulation.
 */

#if NIOS2_DCACHE_SIZE > 0 && !defined(ALT_SIM_OPTIMIZE)

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
#endif

0:
    initd 0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
    bgt r2, zero, 0b
1:

    /*
     * The following debug information tells the ISS not to run the loop above
     * but to perform its actions using faster internal code.
     */
    .pushsection .debug_alt_sim_info
    .int 2, 1, 0b, 1b
    .popsection

#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)

#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2020:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    2024:	ded00014 	ori	sp,sp,16384

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
    2028:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    202c:	d6ad5914 	ori	gp,gp,46436

#else /* NIOS2_NUM_OF_SHADOW_REG_SETS > 0 */

    /*
     * Set up the GP and SP in all shadow register sets.
     */

    /* 
     * Check current register set number, if CPU resets into a shadow register 
     * set, switch register set to 0 by writing zero to SSTATUS register and 
     * execute an ERET instruction that just jumps to the next PC address 
     * (use the NEXTPC instruction to get this).
     */
    
    rdctl r2, status
    
    /* Get the current register set number (STATUS.CRS). */
    andi r3, r2, NIOS2_STATUS_CRS_MSK
    
    /* Skip switch register set if STATUS.CRS is 0.  */
    beq r3, zero, .Lskip_switch_reg_set
    
    .set nobreak
    
    /* Current register set is non-zero, set SSTATUS to 0. */
    mov sstatus, zero
    
    /* Get next pc and store in ea. */
    nextpc ea
    
    /* Point to instruction after eret. */
    addi ea, ea, 8
    
    /* 
     * Execute ERET instruction that just jumps to the next PC address 
     */
    eret
    
.Lskip_switch_reg_set:    
    mov r2, zero
    
    /* Reset STATUS register */
    wrctl status, r2

    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS
    
    /* Set up the stack pointer in register set 0. */
    movhi sp, %hi(__alt_stack_pointer)
    ori sp, sp, %lo(__alt_stack_pointer)
    
    /* Set up the global pointer in register set 0. */
    movhi gp, %hi(_gp)
    ori gp, gp, %lo(_gp)     

.Lsetup_sp_and_gp_loop:
    /* 
     * Setup GP and SP for shadow register set 
     * from NIOS2_NUM_OF_SHADOW_REG_SETS to 0
     */

    /* Skip if number of register sets is 0. */
    beq r3, zero, .Lno_shadow_register_set


    /* Add previous register set STATUS.PRS by 1 */
    movhi r4, 1
    add r2, r2, r4

    /* Write STATUS */
    wrctl status, r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0

    /* Write the GP in previous register set */
    wrprs gp, gp

    /* Only write the SP in previous register set
     * if using the seperate exception stack. For normal case (single stack),
     * funnel code would read the SP from previous register set.
     */
#ifdef ALT_INTERRUPT_STACK

    movhi et, %hiadj(__alt_interrupt_stack_pointer)
    addi  et, et, %lo(__alt_interrupt_stack_pointer)
    wrprs sp, et

#endif /* ALT_INTERRUPT_STACK */

    /* Decrease number of register set counter by 1 */
    addi r3, r3, -1

    br .Lsetup_sp_and_gp_loop
.Lno_shadow_register_set:

#endif /* NIOS2_NUM_OF_SHADOW_REG_SETS */
/*
 * Clear the BSS if not optimizing for RTL simulation.
 *
 * This uses the symbols: __bss_start and __bss_end, which are defined
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    2030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    2034:	108d5f14 	ori	r2,r2,13692

    movhi r3, %hi(__bss_end)
    2038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    203c:	18cda114 	ori	r3,r3,13956

    beq r2, r3, 1f
    2040:	10c00326 	beq	r2,r3,2050 <_start+0x30>

0:
    stw zero, (r2)
    2044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    2048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    204c:	10fffd36 	bltu	r2,r3,2044 <_start+0x24>

1:

    /*
     * The following debug information tells the ISS not to run the loop above
     * but to perform its actions using faster internal code.
     */
    .pushsection .debug_alt_sim_info
    .int 3, 1, 0b, 1b
    .popsection
#endif /* ALT_SIM_OPTIMIZE */

/*
 * The alt_load() facility is normally used when there is no bootloader.
 * It copies some sections into RAM so it acts like a mini-bootloader.
 */
#ifdef CALL_ALT_LOAD

#ifdef ALT_STACK_CHECK
    /*
     * If the user has selected stack checking then we need to set up a safe
     * value in the stack limit register so that the relocation functions
     * don't think the stack has overflowed (the contents of the rwdata
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load

#endif /* CALL_ALT_LOAD */

#ifdef ALT_STACK_CHECK
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    2050:	00032e40 	call	32e4 <alt_main>

00002054 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    2054:	003fff06 	br	2054 <alt_after_alt_main>

00002058 <alt_getch_jtag_uart>:
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 */
int
alt_getch_jtag_uart(void)
{
    2058:	defffd04 	addi	sp,sp,-12
    205c:	dc000115 	stw	r16,4(sp)
   //ALT_DRIVER_READ_EXTERNS(jtag_uart);
   unsigned char c;
   int e;

   e = ALT_DRIVER_READ(jtag_uart, &c, 1, O_NONBLOCK);
    2060:	04000044 	movi	r16,1
    2064:	01000034 	movhi	r4,0
    2068:	210d5d04 	addi	r4,r4,13684
    206c:	d80b883a 	mov	r5,sp
    2070:	800d883a 	mov	r6,r16
    2074:	01d00004 	movi	r7,16384
    2078:	dfc00215 	stw	ra,8(sp)
    207c:	000333c0 	call	333c <altera_avalon_jtag_uart_read>
   if (e == 1)
   {
      return (c);
   }
   else
   {
      return (e);
    2080:	1007883a 	mov	r3,r2
    2084:	1400011e 	bne	r2,r16,208c <alt_getch_jtag_uart+0x34>
    2088:	d8c00003 	ldbu	r3,0(sp)
   }
}
    208c:	1805883a 	mov	r2,r3
    2090:	dfc00217 	ldw	ra,8(sp)
    2094:	dc000117 	ldw	r16,4(sp)
    2098:	dec00304 	addi	sp,sp,12
    209c:	f800283a 	ret

000020a0 <alt_getch_rs232_uart>:
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 */
int
alt_getch_rs232_uart(int readlen)
{
    20a0:	defffc04 	addi	sp,sp,-16
    20a4:	dc000215 	stw	r16,8(sp)
   //ALT_DRIVER_READ_EXTERNS(jtag_uart);
   unsigned char c;
   int e;
   static unsigned char rxbuffer[64];
   static int rdptr = 0;
   static int wrptr = 0;
   static int rxbuflen = 0;

   e = ALT_DRIVER_READ(rs232_uart, &c, 1, O_NONBLOCK);
    20a8:	04000044 	movi	r16,1
    20ac:	dc400115 	stw	r17,4(sp)
    20b0:	800d883a 	mov	r6,r16
    20b4:	2023883a 	mov	r17,r4
    20b8:	d80b883a 	mov	r5,sp
    20bc:	01000034 	movhi	r4,0
    20c0:	210d5c04 	addi	r4,r4,13680
    20c4:	01d00004 	movi	r7,16384
    20c8:	dfc00315 	stw	ra,12(sp)
    20cc:	000339c0 	call	339c <altera_avalon_uart_read>
    20d0:	100d883a 	mov	r6,r2
   if (e == 1)
    20d4:	14000f1e 	bne	r2,r16,2114 <alt_getch_rs232_uart+0x74>
   {
      if (rxbuflen < (sizeof(rxbuffer) / sizeof(rxbuffer[0])))
    20d8:	d1600817 	ldw	r5,-32736(gp)
    20dc:	01c00fc4 	movi	r7,63
    20e0:	39400c36 	bltu	r7,r5,2114 <alt_getch_rs232_uart+0x74>
      {
         // rxbuffer write
         rxbuffer[wrptr++] = c;
    20e4:	d0a00717 	ldw	r2,-32740(gp)
    20e8:	d9000003 	ldbu	r4,0(sp)
    20ec:	00c00034 	movhi	r3,0
    20f0:	18cd7d04 	addi	r3,r3,13812
    20f4:	10c7883a 	add	r3,r2,r3
    20f8:	1405883a 	add	r2,r2,r16
    20fc:	19000005 	stb	r4,0(r3)
    2100:	d0a00715 	stw	r2,-32740(gp)
         if (wrptr >= (sizeof(rxbuffer) / sizeof(rxbuffer[0])))
    2104:	3880012e 	bgeu	r7,r2,210c <alt_getch_rs232_uart+0x6c>
         {
            wrptr = 0;
    2108:	d0200715 	stw	zero,-32740(gp)
         }
         rxbuflen++;
    210c:	2985883a 	add	r2,r5,r6
    2110:	d0a00815 	stw	r2,-32736(gp)
    2114:	d1200817 	ldw	r4,-32736(gp)
      }
      else
      {
         // rxbuffer full: char discarded
         // !! Debug !!
    	   //alt_putch_rs232_uart("!", 1);
         // !! Debug !!
      }
   }

   if (readlen <= 0)
   {
      // readlen <= 0 : query mode, return current rxbuflen
      return (rxbuflen);
    2118:	2005883a 	mov	r2,r4
    211c:	0440100e 	bge	zero,r17,2160 <alt_getch_rs232_uart+0xc0>
   }
   else if (readlen <= rxbuflen)
   {
      // readlen > 0 : read mode 
      // readlen <= rxbuflen --> there are at least 'readlen' chars to read, return one char at a time
      c = rxbuffer[rdptr++];
      if (rdptr >= (sizeof(rxbuffer) / sizeof(rxbuffer[0])))
      {
         rdptr = 0;
      }
      rxbuflen--;

      return (c);
   }
   else
   {
      // readlen > 0 : read mode 
      // readlen > rxbuflen  --> waiting for 'readlen' chars, return '-EWOULDBLOCK'
      return (-EWOULDBLOCK);
    2120:	00bffd44 	movi	r2,-11
    2124:	24400e16 	blt	r4,r17,2160 <alt_getch_rs232_uart+0xc0>
    2128:	d0a00617 	ldw	r2,-32744(gp)
    212c:	00c00034 	movhi	r3,0
    2130:	18cd7d04 	addi	r3,r3,13812
    2134:	10c7883a 	add	r3,r2,r3
    2138:	19400003 	ldbu	r5,0(r3)
    213c:	10800044 	addi	r2,r2,1
    2140:	00c00fc4 	movi	r3,63
    2144:	d0a00615 	stw	r2,-32744(gp)
    2148:	d9400005 	stb	r5,0(sp)
    214c:	1880012e 	bgeu	r3,r2,2154 <alt_getch_rs232_uart+0xb4>
    2150:	d0200615 	stw	zero,-32744(gp)
    2154:	20bfffc4 	addi	r2,r4,-1
    2158:	d0a00815 	stw	r2,-32736(gp)
    215c:	28803fcc 	andi	r2,r5,255
   }
}
    2160:	dfc00317 	ldw	ra,12(sp)
    2164:	dc000217 	ldw	r16,8(sp)
    2168:	dc400117 	ldw	r17,4(sp)
    216c:	dec00404 	addi	sp,sp,16
    2170:	f800283a 	ret

00002174 <alt_putch_jtag_uart>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 */
int
alt_putch_jtag_uart(int c, int blockflag, void (* const in_loop_callback)(void))
{
    2174:	defffa04 	addi	sp,sp,-24
    2178:	dc000415 	stw	r16,16(sp)
    217c:	dc400315 	stw	r17,12(sp)
    2180:	dcc00115 	stw	r19,4(sp)
    2184:	dfc00515 	stw	ra,20(sp)
    2188:	dc800215 	stw	r18,8(sp)
    218c:	2023883a 	mov	r17,r4
    2190:	2827883a 	mov	r19,r5
    2194:	3021883a 	mov	r16,r6
   //ALT_DRIVER_WRITE_EXTERNS(ALT_PUTCH_DEV);
   char c1 = (char)(c & 0xff);
    2198:	d9000005 	stb	r4,0(sp)
   int e;

   while (1)
   {
      //// polling read
      //alt_getch_jtag_uart();
      if (in_loop_callback != NULL)
         (in_loop_callback)();

      e = ALT_DRIVER_WRITE(ALT_PUTCH_DEV, &c1, 1, O_NONBLOCK);
    219c:	04800044 	movi	r18,1
    21a0:	80000126 	beq	r16,zero,21a8 <alt_putch_jtag_uart+0x34>
    21a4:	803ee83a 	callr	r16
    21a8:	01000034 	movhi	r4,0
    21ac:	210d5d04 	addi	r4,r4,13684
    21b0:	d80b883a 	mov	r5,sp
    21b4:	900d883a 	mov	r6,r18
    21b8:	01d00004 	movi	r7,16384
    21bc:	00024140 	call	2414 <altera_avalon_jtag_uart_write>
    21c0:	1007883a 	mov	r3,r2
      if (e == 1)
    21c4:	1480021e 	bne	r2,r18,21d0 <alt_putch_jtag_uart+0x5c>
      {
         // putch done
         return (c);
    21c8:	8805883a 	mov	r2,r17
    21cc:	00000406 	br	21e0 <alt_putch_jtag_uart+0x6c>
      }
      else if (e == -EWOULDBLOCK)
    21d0:	00bffd44 	movi	r2,-11
    21d4:	1880011e 	bne	r3,r2,21dc <alt_putch_jtag_uart+0x68>
      {
         // jtag uart not ready
         if (!blockflag)
    21d8:	983ff01e 	bne	r19,zero,219c <alt_putch_jtag_uart+0x28>
         {
            // non-blocking mode: exit
            return (e);
         }
         else
         {
            // blocking mode: retry
         }
      }
      else
      {
         // error/timeout: exit
         return (e);
    21dc:	1805883a 	mov	r2,r3
      } 
   }
}
    21e0:	dfc00517 	ldw	ra,20(sp)
    21e4:	dc000417 	ldw	r16,16(sp)
    21e8:	dc400317 	ldw	r17,12(sp)
    21ec:	dc800217 	ldw	r18,8(sp)
    21f0:	dcc00117 	ldw	r19,4(sp)
    21f4:	dec00604 	addi	sp,sp,24
    21f8:	f800283a 	ret

000021fc <alt_test_jtag_uart>:


int
alt_test_jtag_uart(void)
{
    //ALT_DRIVER_WRITE_EXTERNS(ALT_PUTCH_DEV);

    return ALT_DRIVER_WRITE(ALT_PUTCH_DEV, NULL, 0, O_NONBLOCK);
    21fc:	01000034 	movhi	r4,0
    2200:	210d5d04 	addi	r4,r4,13684
    2204:	000b883a 	mov	r5,zero
    2208:	000d883a 	mov	r6,zero
    220c:	01d00004 	movi	r7,16384
    2210:	02000034 	movhi	r8,0
    2214:	42090504 	addi	r8,r8,9236
    2218:	4000683a 	jmp	r8

0000221c <alt_putch_rs232_uart>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 */
int
alt_putch_rs232_uart(int c, int blockflag, void (* const in_loop_callback)(void))
{
    221c:	defffa04 	addi	sp,sp,-24
    2220:	dc000415 	stw	r16,16(sp)
    2224:	dc400315 	stw	r17,12(sp)
    2228:	dcc00115 	stw	r19,4(sp)
    222c:	dfc00515 	stw	ra,20(sp)
    2230:	dc800215 	stw	r18,8(sp)
    2234:	2023883a 	mov	r17,r4
    2238:	2827883a 	mov	r19,r5
    223c:	3021883a 	mov	r16,r6
   //ALT_DRIVER_WRITE_EXTERNS(ALT_PUTCH_DEV);
   char c1 = (char)(c & 0xff);
    2240:	d9000005 	stb	r4,0(sp)
   int e;

   while (1)
   {
      //// polling read
      //alt_getch_rs232_uart();
      if (in_loop_callback != NULL)
         (in_loop_callback)();

      e = ALT_DRIVER_WRITE(ALT_PUTCH_DEV, &c1, 1, O_NONBLOCK);
    2244:	04800044 	movi	r18,1
    2248:	80000126 	beq	r16,zero,2250 <alt_putch_rs232_uart+0x34>
    224c:	803ee83a 	callr	r16
    2250:	01000034 	movhi	r4,0
    2254:	210d5c04 	addi	r4,r4,13680
    2258:	d80b883a 	mov	r5,sp
    225c:	900d883a 	mov	r6,r18
    2260:	01d00004 	movi	r7,16384
    2264:	00024800 	call	2480 <altera_avalon_uart_write>
    2268:	1007883a 	mov	r3,r2
      if (e == 1)
    226c:	1480021e 	bne	r2,r18,2278 <alt_putch_rs232_uart+0x5c>
      {
         // putch done
         return (c);
    2270:	8805883a 	mov	r2,r17
    2274:	00000406 	br	2288 <alt_putch_rs232_uart+0x6c>
      }
      else if (e == -EWOULDBLOCK)
    2278:	00bffd44 	movi	r2,-11
    227c:	1880011e 	bne	r3,r2,2284 <alt_putch_rs232_uart+0x68>
      {
         // rs232 uart not ready
         if (!blockflag)
    2280:	983ff01e 	bne	r19,zero,2244 <alt_putch_rs232_uart+0x28>
         {
            // non-blocking mode: exit
            return (e);
         }
         else
         {
            // blocking mode: retry
         }
      }
      else
      {
         // error/timeout: exit
         return (e);
    2284:	1805883a 	mov	r2,r3
      } 
   }
}
    2288:	dfc00517 	ldw	ra,20(sp)
    228c:	dc000417 	ldw	r16,16(sp)
    2290:	dc400317 	ldw	r17,12(sp)
    2294:	dc800217 	ldw	r18,8(sp)
    2298:	dcc00117 	ldw	r19,4(sp)
    229c:	dec00604 	addi	sp,sp,24
    22a0:	f800283a 	ret

000022a4 <alt_test_rs232_uart>:


int
alt_test_rs232_uart(void)
{
   //ALT_DRIVER_WRITE_EXTERNS(ALT_PUTCH_DEV);

   return ALT_DRIVER_WRITE(ALT_PUTCH_DEV, NULL, 0, O_NONBLOCK);
    22a4:	01000034 	movhi	r4,0
    22a8:	210d5c04 	addi	r4,r4,13680
    22ac:	000b883a 	mov	r5,zero
    22b0:	000d883a 	mov	r6,zero
    22b4:	01d00004 	movi	r7,16384
    22b8:	02000034 	movhi	r8,0
    22bc:	42092004 	addi	r8,r8,9344
    22c0:	4000683a 	jmp	r8

000022c4 <alt_putstr_jtag_uart>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 */
int 
alt_putstr_jtag_uart(const char* str, int blockflag, void (* const in_loop_callback)(void))
{
    22c4:	defffa04 	addi	sp,sp,-24
    22c8:	dc000415 	stw	r16,16(sp)
    22cc:	dc400315 	stw	r17,12(sp)
    22d0:	dc800215 	stw	r18,8(sp)
    22d4:	dd000015 	stw	r20,0(sp)
    22d8:	dfc00515 	stw	ra,20(sp)
    22dc:	dcc00115 	stw	r19,4(sp)
   const char *p;
   int e;

   e = 0;
   p = str;
   while (*p)
   {
      //// polling read
      //alt_getch_jtag_uart(0);
      if (in_loop_callback != NULL)
         (in_loop_callback)();

      e = ALT_DRIVER_WRITE(ALT_PUTCH_DEV, p, 1, O_NONBLOCK);
      if (e == 1)
      {
         // next char
         p++;
      }
      else if (e == -EWOULDBLOCK)
      {
         // jtag uart not ready
         if (!blockflag)
         {
            // non-blocking mode: exit
            break;
         }
         else
         {
            // blocking mode: retry
         }
      }
      else
      {
         // error/timeout: exit
         break;
    22e0:	20800007 	ldb	r2,0(r4)
    22e4:	2023883a 	mov	r17,r4
    22e8:	2829883a 	mov	r20,r5
    22ec:	3025883a 	mov	r18,r6
    22f0:	2021883a 	mov	r16,r4
    22f4:	10001426 	beq	r2,zero,2348 <alt_putstr_jtag_uart+0x84>
    22f8:	04c00044 	movi	r19,1
    22fc:	90000126 	beq	r18,zero,2304 <alt_putstr_jtag_uart+0x40>
    2300:	903ee83a 	callr	r18
    2304:	800b883a 	mov	r5,r16
    2308:	01000034 	movhi	r4,0
    230c:	210d5d04 	addi	r4,r4,13684
    2310:	980d883a 	mov	r6,r19
    2314:	01d00004 	movi	r7,16384
    2318:	00024140 	call	2414 <altera_avalon_jtag_uart_write>
    231c:	1007883a 	mov	r3,r2
    2320:	14c0021e 	bne	r2,r19,232c <alt_putstr_jtag_uart+0x68>
    2324:	80a1883a 	add	r16,r16,r2
    2328:	00000306 	br	2338 <alt_putstr_jtag_uart+0x74>
    232c:	00bffd44 	movi	r2,-11
    2330:	1880031e 	bne	r3,r2,2340 <alt_putstr_jtag_uart+0x7c>
    2334:	a0000226 	beq	r20,zero,2340 <alt_putstr_jtag_uart+0x7c>
    2338:	80800007 	ldb	r2,0(r16)
    233c:	103fee1e 	bne	r2,zero,22f8 <alt_putstr_jtag_uart+0x34>
      }
   }

   if (e >= 0)
      return (p - str);
   else
      return (e);
    2340:	1805883a 	mov	r2,r3
    2344:	18000116 	blt	r3,zero,234c <alt_putstr_jtag_uart+0x88>
    2348:	8445c83a 	sub	r2,r16,r17
}
    234c:	dfc00517 	ldw	ra,20(sp)
    2350:	dc000417 	ldw	r16,16(sp)
    2354:	dc400317 	ldw	r17,12(sp)
    2358:	dc800217 	ldw	r18,8(sp)
    235c:	dcc00117 	ldw	r19,4(sp)
    2360:	dd000017 	ldw	r20,0(sp)
    2364:	dec00604 	addi	sp,sp,24
    2368:	f800283a 	ret

0000236c <alt_putstr_rs232_uart>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 */
int
alt_putstr_rs232_uart(const char* str, int blockflag, void (* const in_loop_callback)(void))
{
    236c:	defffa04 	addi	sp,sp,-24
    2370:	dc000415 	stw	r16,16(sp)
    2374:	dc400315 	stw	r17,12(sp)
    2378:	dc800215 	stw	r18,8(sp)
    237c:	dd000015 	stw	r20,0(sp)
    2380:	dfc00515 	stw	ra,20(sp)
    2384:	dcc00115 	stw	r19,4(sp)
   const char *p;
   int e;

   e = 0;
   p = str;
   while (*p)
   {
      //// polling read
      //alt_getch_rs232_uart(0);
      if (in_loop_callback != NULL)
         (in_loop_callback)();

      e = ALT_DRIVER_WRITE(ALT_PUTCH_DEV, p, 1, O_NONBLOCK);
      if (e == 1)
      {
         // next char
         p++;
      }
      else if (e == -EWOULDBLOCK)
      {
         // rs232 uart not ready
         if (!blockflag)
         {
            // non-blocking mode: exit
            break;
         }
         else
         {
            // blocking mode: retry
         }
      }
      else
      {
         // error/timeout: exit
         break;
    2388:	20800007 	ldb	r2,0(r4)
    238c:	2023883a 	mov	r17,r4
    2390:	2829883a 	mov	r20,r5
    2394:	3025883a 	mov	r18,r6
    2398:	2021883a 	mov	r16,r4
    239c:	10001426 	beq	r2,zero,23f0 <alt_putstr_rs232_uart+0x84>
    23a0:	04c00044 	movi	r19,1
    23a4:	90000126 	beq	r18,zero,23ac <alt_putstr_rs232_uart+0x40>
    23a8:	903ee83a 	callr	r18
    23ac:	800b883a 	mov	r5,r16
    23b0:	01000034 	movhi	r4,0
    23b4:	210d5c04 	addi	r4,r4,13680
    23b8:	980d883a 	mov	r6,r19
    23bc:	01d00004 	movi	r7,16384
    23c0:	00024800 	call	2480 <altera_avalon_uart_write>
    23c4:	1007883a 	mov	r3,r2
    23c8:	14c0021e 	bne	r2,r19,23d4 <alt_putstr_rs232_uart+0x68>
    23cc:	80a1883a 	add	r16,r16,r2
    23d0:	00000306 	br	23e0 <alt_putstr_rs232_uart+0x74>
    23d4:	00bffd44 	movi	r2,-11
    23d8:	1880031e 	bne	r3,r2,23e8 <alt_putstr_rs232_uart+0x7c>
    23dc:	a0000226 	beq	r20,zero,23e8 <alt_putstr_rs232_uart+0x7c>
    23e0:	80800007 	ldb	r2,0(r16)
    23e4:	103fee1e 	bne	r2,zero,23a0 <alt_putstr_rs232_uart+0x34>
      }
   }

   if (e >= 0)
      return (p - str);
   else
      return (e);
    23e8:	1805883a 	mov	r2,r3
    23ec:	18000116 	blt	r3,zero,23f4 <alt_putstr_rs232_uart+0x88>
    23f0:	8445c83a 	sub	r2,r16,r17
}
    23f4:	dfc00517 	ldw	ra,20(sp)
    23f8:	dc000417 	ldw	r16,16(sp)
    23fc:	dc400317 	ldw	r17,12(sp)
    2400:	dc800217 	ldw	r18,8(sp)
    2404:	dcc00117 	ldw	r19,4(sp)
    2408:	dd000017 	ldw	r20,0(sp)
    240c:	dec00604 	addi	sp,sp,24
    2410:	f800283a 	ret

00002414 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */
int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp,
  const char * ptr, int count, int flags)
{
    2414:	39d0000c 	andi	r7,r7,16384
    2418:	380f003a 	cmpeq	r7,r7,zero
  int len = count;
    241c:	3011883a 	mov	r8,r6
    2420:	0270d3d4 	movui	r9,49999
  static int timeout = 0;

  /* Standard write op with timeout */
  do 
  {
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    2424:	20c00017 	ldw	r3,0(r4)
    2428:	18800137 	ldwio	r2,4(r3)
    242c:	10bfffec 	andhi	r2,r2,65535
    2430:	10000726 	beq	r2,zero,2450 <altera_avalon_jtag_uart_write+0x3c>
    {
      // jtag uart ready 
      timeout = 0;
    2434:	d0200915 	stw	zero,-32732(gp)
      if (count > 0)
    2438:	01800e0e 	bge	zero,r6,2474 <altera_avalon_jtag_uart_write+0x60>
      {
        // write op
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(sp->base, *ptr++);
    243c:	28800007 	ldb	r2,0(r5)
    2440:	18800035 	stwio	r2,0(r3)
    2444:	29400044 	addi	r5,r5,1
        count--;
    2448:	31bfffc4 	addi	r6,r6,-1
    244c:	00000906 	br	2474 <altera_avalon_jtag_uart_write+0x60>
      }
    }
    else if (timeout >= 50000) // Note: fclk=50MHz, 0.5MHz loop --> 0.1s timeout
    2450:	d0a00917 	ldw	r2,-32732(gp)
    {
      // timeout (hw error / Host not connected)
      return (-EIO);
    }
    else 
    {   
      timeout++;  
    2454:	10c00044 	addi	r3,r2,1
    2458:	4880020e 	bge	r9,r2,2464 <altera_avalon_jtag_uart_write+0x50>
    245c:	00bffec4 	movi	r2,-5
    2460:	f800283a 	ret
    2464:	d0e00915 	stw	r3,-32732(gp)
      if (flags & O_NONBLOCK) 
    2468:	3800021e 	bne	r7,zero,2474 <altera_avalon_jtag_uart_write+0x60>
      {
        // non-blocking mode: exit
        return (-EWOULDBLOCK);
    246c:	00bffd44 	movi	r2,-11
    2470:	f800283a 	ret
      }
      else
      {  
        // blocking mode: retry
      }
    }
  }
    2474:	01bfeb16 	blt	zero,r6,2424 <altera_avalon_jtag_uart_write+0x10>
  while (count > 0);
  // Note: standard write op will block/not block according 
  // to O_NONBLOCK request. Driver is forced into non-blocking mode
  // when timeout detected: for each call driver checks interface status 
  // returning -EIO when timeout; driver automatically restarts when 
  // interface is ready.
  // Note1: call to low level driver with 'count = 0 and O_NONBLOCK mode'
  // works as interface status check (consecutive calls will return -EWOULDBLOCK 
  // when 'retry loop', -EIO when 'timeout', zero when 'interface is ready').

  return (len);
    2478:	4005883a 	mov	r2,r8
}
    247c:	f800283a 	ret

00002480 <altera_avalon_uart_write>:

int 
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
    2480:	39d0000c 	andi	r7,r7,16384
    2484:	380f003a 	cmpeq	r7,r7,zero
  int count = len;
    2488:	3011883a 	mov	r8,r6
    248c:	0240f9c4 	movi	r9,999
  static int timeout = 0;

  /* Standard write op with timeout */
  do 
  {
    if ((IORD_ALTERA_AVALON_UART_STATUS(sp->base) & ALTERA_AVALON_UART_STATUS_TRDY_MSK) != 0)
    2490:	20c00017 	ldw	r3,0(r4)
    2494:	18800237 	ldwio	r2,8(r3)
    2498:	1080100c 	andi	r2,r2,64
    249c:	10000726 	beq	r2,zero,24bc <altera_avalon_uart_write+0x3c>
    {
      // uart ready 
      timeout = 0;
    24a0:	d0200a15 	stw	zero,-32728(gp)
      if (count > 0)
    24a4:	02000e0e 	bge	zero,r8,24e0 <altera_avalon_uart_write+0x60>
      {
        // write op
        IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, *ptr++);
    24a8:	28800007 	ldb	r2,0(r5)
    24ac:	18800135 	stwio	r2,4(r3)
    24b0:	29400044 	addi	r5,r5,1
        count--;
    24b4:	423fffc4 	addi	r8,r8,-1
    24b8:	00000906 	br	24e0 <altera_avalon_uart_write+0x60>
      }
    }
    else if (timeout >= (2 * 500)) // Note: fclk=50MHz, 1MHz loop --> constant baud-rate 19200bps, 2*500us timeout
    24bc:	d0a00a17 	ldw	r2,-32728(gp)
    {  
      // timeout (hw error / wrong baud rate)
      return (-EIO);
    }
    else 
    {   
      timeout++;  
    24c0:	10c00044 	addi	r3,r2,1
    24c4:	4880020e 	bge	r9,r2,24d0 <altera_avalon_uart_write+0x50>
    24c8:	01bffec4 	movi	r6,-5
    24cc:	00000506 	br	24e4 <altera_avalon_uart_write+0x64>
    24d0:	d0e00a15 	stw	r3,-32728(gp)
      if (flags & O_NONBLOCK) 
    24d4:	3800021e 	bne	r7,zero,24e0 <altera_avalon_uart_write+0x60>
      {
        // non-blocking mode: exit
        return (-EWOULDBLOCK);
    24d8:	01bffd44 	movi	r6,-11
    24dc:	00000106 	br	24e4 <altera_avalon_uart_write+0x64>
      }
      else
      {  
        // blocking mode: retry
      }
    }
  }  
    24e0:	023feb16 	blt	zero,r8,2490 <altera_avalon_uart_write+0x10>
  while (count > 0);
  // Note: standard write op will block/not block according 
  // to O_NONBLOCK request. Driver is forced into non-blocking mode
  // when timeout detected: for each call driver checks interface status 
  // returning -EIO when timeout; driver automatically restarts when 
  // interface is ready.
  // Note1: call to low level driver with 'count = 0 and O_NONBLOCK mode'
  // works as interface status check (consecutive calls will return -EWOULDBLOCK 
  // when 'retry loop', -EIO when 'timeout', zero when 'interface is ready').

  return (len);
}
    24e4:	3005883a 	mov	r2,r6
    24e8:	f800283a 	ret

000024ec <wait>:
   volatile int b;

   while (counter--)
   {
      a = a + b;
    24ec:	213fffc4 	addi	r4,r4,-1
    24f0:	00bfffc4 	movi	r2,-1
    24f4:	deffff04 	addi	sp,sp,-4
    24f8:	0007883a 	mov	r3,zero
    24fc:	20800526 	beq	r4,r2,2514 <wait+0x28>
    2500:	100b883a 	mov	r5,r2
    2504:	d8800017 	ldw	r2,0(sp)
    2508:	213fffc4 	addi	r4,r4,-1
    250c:	1887883a 	add	r3,r3,r2
    2510:	217ffc1e 	bne	r4,r5,2504 <wait+0x18>
   }

   return (a);
}
    2514:	1805883a 	mov	r2,r3
    2518:	dec00104 	addi	sp,sp,4
    251c:	f800283a 	ret

00002520 <W4>:


void W4(int addr, int dat)
{
    2520:	defffc04 	addi	sp,sp,-16
    2524:	dc400115 	stw	r17,4(sp)
   //usleep(5000);
   DELAY(5000);
    2528:	0449c404 	movi	r17,10000
    252c:	dc800015 	stw	r18,0(sp)
    2530:	2025883a 	mov	r18,r4
    2534:	8809883a 	mov	r4,r17
    2538:	dc000215 	stw	r16,8(sp)
    253c:	dfc00315 	stw	ra,12(sp)
    2540:	2821883a 	mov	r16,r5
    2544:	00024ec0 	call	24ec <wait>
   IOWR_32DIRECT(addr, 0, dat);
    2548:	94000035 	stwio	r16,0(r18)
   DELAY(5000);
    254c:	8809883a 	mov	r4,r17
    2550:	02000034 	movhi	r8,0
    2554:	42093b04 	addi	r8,r8,9452
    2558:	dfc00317 	ldw	ra,12(sp)
    255c:	dc000217 	ldw	r16,8(sp)
    2560:	dc400117 	ldw	r17,4(sp)
    2564:	dc800017 	ldw	r18,0(sp)
    2568:	dec00404 	addi	sp,sp,16
    256c:	4000683a 	jmp	r8

00002570 <R4>:
   //usleep(5000);
   /* Note: some commands cannot be sent too fast (i.e. MDIO r/w access) --> 5ms pause interval */
}


int R4(int addr)
{
   return (IORD_32DIRECT(addr, 0));
}
    2570:	20800037 	ldwio	r2,0(r4)
    2574:	f800283a 	ret

00002578 <cmdinit>:


int cmdinit(void)
{
    2578:	defffe04 	addi	sp,sp,-8
    257c:	dc000015 	stw	r16,0(sp)
   /* Configuration for RGMII mode */
   /* Note: SGMII mode --> config skipped, power on defaults to sgmii
   W4(0x810, 0x25B );
   W4(0x818, 0x808B);
   W4(0x810, 0x258 );
   W4(0x818, 0x4108);
   W4(0x810, 0x254 );
   W4(0x818, 0xCEB );
   W4(0x810, 0x240 );
   W4(0x818, 0x9140);
   W4(0x818, 0x1140);
   */

   // Software Reset
/* // !! Debug !! Reset skipped !!
   W4(0xb00, 0x9140);
   W4(0xb08, 0x1140);
   W4(0xb10, 0x9140);
   W4(0xb18, 0x1140);
   W4(0xb20, 0x9140);
   W4(0xb28, 0x1140);
   W4(0xb30, 0x9140);
   W4(0xb38, 0x1140);
   W4(0xb40, 0x9140);
   W4(0xb48, 0x1140);
   W4(0xb50, 0x9140);
   W4(0xb58, 0x1140);
   W4(0xb60, 0x9140);
   W4(0xb68, 0x1140);
   W4(0xb70, 0x9140);
   W4(0xb78, 0x1140);
*/ // !! Debug !! Reset skipped !!

   // CPU_TXPORT enabled (reg1.15 = wena, reg1.10..0 = wframelen = 256)
   W4(0x844, 0x8100); // eth0
    2580:	04204014 	movui	r16,33024
    2584:	800b883a 	mov	r5,r16
    2588:	01021104 	movi	r4,2116
    258c:	dfc00115 	stw	ra,4(sp)
    2590:	00025200 	call	2520 <W4>
   W4(0x884, 0x8100); // eth1
    2594:	800b883a 	mov	r5,r16
    2598:	01022104 	movi	r4,2180
    259c:	00025200 	call	2520 <W4>
   W4(0x8C4, 0x8100); // eth2
    25a0:	800b883a 	mov	r5,r16
    25a4:	01023104 	movi	r4,2244
    25a8:	00025200 	call	2520 <W4>
   W4(0x904, 0x8100); // eth3
    25ac:	800b883a 	mov	r5,r16
    25b0:	01024104 	movi	r4,2308
    25b4:	00025200 	call	2520 <W4>
   W4(0x944, 0x8100); // eth4
    25b8:	800b883a 	mov	r5,r16
    25bc:	01025104 	movi	r4,2372
    25c0:	00025200 	call	2520 <W4>
   W4(0x984, 0x8100); // eth5
    25c4:	800b883a 	mov	r5,r16
    25c8:	01026104 	movi	r4,2436
    25cc:	00025200 	call	2520 <W4>
   W4(0x9C4, 0x8100); // eth6
    25d0:	800b883a 	mov	r5,r16
    25d4:	01027104 	movi	r4,2500
    25d8:	00025200 	call	2520 <W4>
   W4(0xA04, 0x8100); // eth7
    25dc:	800b883a 	mov	r5,r16
    25e0:	01028104 	movi	r4,2564

   // CPU_RXPORT enabled (reg15.15 = rena)
   W4(0x87C, 0x8000); // eth0
    25e4:	04200014 	movui	r16,32768
    25e8:	00025200 	call	2520 <W4>
    25ec:	800b883a 	mov	r5,r16
    25f0:	01021f04 	movi	r4,2172
    25f4:	00025200 	call	2520 <W4>
   W4(0x8BC, 0x8000); // eth1
    25f8:	800b883a 	mov	r5,r16
    25fc:	01022f04 	movi	r4,2236
    2600:	00025200 	call	2520 <W4>
   W4(0x8FC, 0x8000); // eth2
    2604:	800b883a 	mov	r5,r16
    2608:	01023f04 	movi	r4,2300
    260c:	00025200 	call	2520 <W4>
   W4(0x93C, 0x8000); // eth3
    2610:	800b883a 	mov	r5,r16
    2614:	01024f04 	movi	r4,2364
    2618:	00025200 	call	2520 <W4>
   W4(0x97C, 0x8000); // eth4
    261c:	800b883a 	mov	r5,r16
    2620:	01025f04 	movi	r4,2428
    2624:	00025200 	call	2520 <W4>
   W4(0x9BC, 0x8000); // eth5
    2628:	800b883a 	mov	r5,r16
    262c:	01026f04 	movi	r4,2492
    2630:	00025200 	call	2520 <W4>
   W4(0x9FC, 0x8000); // eth6
    2634:	800b883a 	mov	r5,r16
    2638:	01027f04 	movi	r4,2556
    263c:	00025200 	call	2520 <W4>
   W4(0xA3C, 0x8000); // eth7
    2640:	800b883a 	mov	r5,r16
    2644:	01028f04 	movi	r4,2620
    2648:	00025200 	call	2520 <W4>

   return 0;
}
    264c:	0005883a 	mov	r2,zero
    2650:	dfc00117 	ldw	ra,4(sp)
    2654:	dc000017 	ldw	r16,0(sp)
    2658:	dec00204 	addi	sp,sp,8
    265c:	f800283a 	ret

00002660 <idle_function>:


//
// idle_function called by blocking operations
//
void idle_function(void)
{
   alt_getch_rs232_uart(0);
    2660:	0009883a 	mov	r4,zero
    2664:	02000034 	movhi	r8,0
    2668:	42082804 	addi	r8,r8,8352
    266c:	4000683a 	jmp	r8

00002670 <eth_getch>:
   // NOTE: rs232 chars captured by function 'alt_getch_rs232_uart'
   // (rs232 uart does not have hardware buffer and interrupts are not in use,
   // data is accumulated into function 'alt_getch_rs232_uart()' static buffer)

   //alt_getch_jtag_uart();
   // NOTE: jtag uart has tx/rx hardware buffers so callback not needed
}


#define ETH_REG0  (0x840)
#define ETH_REG1  (0x844)
#define ETH_REG14 (0x878)
#define ETH_REG15 (0x87C)

int eth_getch(int eth)
{
   int r;
   int s;
   int c;
   int REG14;
   int REG15;

   REG14 = ETH_REG14 + ((eth & 0x7) << 6);
    2670:	210001cc 	andi	r4,r4,7
    2674:	200891ba 	slli	r4,r4,6
   REG15 = ETH_REG15 + ((eth & 0x7) << 6);
    2678:	21421f04 	addi	r5,r4,2172
    267c:	21021e04 	addi	r4,r4,2168

   s = IORD_32DIRECT(REG15, 0);
    2680:	29c00037 	ldwio	r7,0(r5)
   if ((s & 0xC0000000) == 0x80000000)
    2684:	00a00034 	movhi	r2,32768
    2688:	10800004 	addi	r2,r2,0
    268c:	39b0002c 	andhi	r6,r7,49152
   {
      // Frame Ready (rready, not reoframe) : read pulse
      IOWR_32DIRECT(REG15, 0, (s |  0x00001000));
    2690:	38c40014 	ori	r3,r7,4096
    2694:	3080151e 	bne	r6,r2,26ec <eth_getch+0x7c>
    2698:	28c00035 	stwio	r3,0(r5)
      IOWR_32DIRECT(REG15, 0, (s & ~0x00001000));
    269c:	00bbffc4 	movi	r2,-4097
    26a0:	3884703a 	and	r2,r7,r2
    26a4:	28800035 	stwio	r2,0(r5)
      r = IORD_32DIRECT(REG14, 0);
    26a8:	21000037 	ldwio	r4,0(r4)
      eth_srcaddr = (r & 0x0000FF00) >> 8;
    26ac:	20bfc00c 	andi	r2,r4,65280
      eth_srcport = (r & 0x000F0000) >> 16;
    26b0:	20c003ec 	andhi	r3,r4,15
    26b4:	1807d43a 	srai	r3,r3,16
    26b8:	1005d23a 	srai	r2,r2,8
      c = r & 0xFF;
    26bc:	21003fcc 	andi	r4,r4,255
    26c0:	d0e02215 	stw	r3,-32632(gp)
      if (c == 0)
      {
         // End of string: flush remaining data using ack pulse
         IOWR_32DIRECT(REG15, 0, (s |  0x00002000));
    26c4:	39880014 	ori	r6,r7,8192
    26c8:	d0a02115 	stw	r2,-32636(gp)
         IOWR_32DIRECT(REG15, 0, (s & ~0x00002000));
         return (-1);
      }
      return (c);
    26cc:	2007883a 	mov	r3,r4
    26d0:	20000f1e 	bne	r4,zero,2710 <eth_getch+0xa0>
    26d4:	29800035 	stwio	r6,0(r5)
    26d8:	00b7ffc4 	movi	r2,-8193
    26dc:	3884703a 	and	r2,r7,r2
    26e0:	28800035 	stwio	r2,0(r5)
    26e4:	00ffffc4 	movi	r3,-1
    26e8:	00000906 	br	2710 <eth_getch+0xa0>
   }
   else if ((s & 0xC0000000) == 0xC0000000)
    26ec:	00b00034 	movhi	r2,49152
    26f0:	10800004 	addi	r2,r2,0
   {
      // End of frame: ack pulse
      IOWR_32DIRECT(REG15, 0, (s |  0x00002000));
    26f4:	39080014 	ori	r4,r7,8192
      IOWR_32DIRECT(REG15, 0, (s & ~0x00002000));
      return (-1);
   }

   return (-1);
    26f8:	00ffffc4 	movi	r3,-1
    26fc:	3080041e 	bne	r6,r2,2710 <eth_getch+0xa0>
    2700:	29000035 	stwio	r4,0(r5)
    2704:	00b7ffc4 	movi	r2,-8193
    2708:	3884703a 	and	r2,r7,r2
    270c:	28800035 	stwio	r2,0(r5)
}
    2710:	1805883a 	mov	r2,r3
    2714:	f800283a 	ret

00002718 <eth_putchar>:


int eth_putchar(int eth, int c)
{
   int s;
   int REG0;
   int REG1;

   REG0 = ETH_REG0 + ((eth & 0x7) << 6);
    2718:	210001cc 	andi	r4,r4,7
    271c:	200891ba 	slli	r4,r4,6
   REG1 = ETH_REG1 + ((eth & 0x7) << 6);
    2720:	21821104 	addi	r6,r4,2116
    2724:	21021004 	addi	r4,r4,2112

   s = IORD_32DIRECT(REG1, 0);
    2728:	32000037 	ldwio	r8,0(r6)
   if ((s & 0xA0000000) == 0x80000000)
    272c:	00a00034 	movhi	r2,32768
    2730:	10800004 	addi	r2,r2,0
    2734:	40e8002c 	andhi	r3,r8,40960
   {
      // Ready + NotFull: write pulse
      IOWR_32DIRECT(REG0, 0, (c & 0xFF));
    2738:	29403fcc 	andi	r5,r5,255
      IOWR_32DIRECT(REG1, 0, (s & ~0x00007000));
      s = IORD_32DIRECT(REG1, 0);
      IOWR_32DIRECT(REG1, 0, (s |  0x00001000));
      return (1);
   }
   else
   {
      return (0);
    273c:	000f883a 	mov	r7,zero
    2740:	1880081e 	bne	r3,r2,2764 <eth_putchar+0x4c>
    2744:	21400035 	stwio	r5,0(r4)
    2748:	00a3ffc4 	movi	r2,-28673
    274c:	4084703a 	and	r2,r8,r2
    2750:	30800035 	stwio	r2,0(r6)
    2754:	32000037 	ldwio	r8,0(r6)
    2758:	40840014 	ori	r2,r8,4096
    275c:	30800035 	stwio	r2,0(r6)
    2760:	01c00044 	movi	r7,1
   }
}
    2764:	3805883a 	mov	r2,r7
    2768:	f800283a 	ret

0000276c <eth_putstr>:


int eth_putstr(int eth, char *str, void (* const in_loop_callback)(void))
{
    276c:	defffb04 	addi	sp,sp,-20
    2770:	dc000315 	stw	r16,12(sp)
    2774:	dc400215 	stw	r17,8(sp)
    2778:	dc800115 	stw	r18,4(sp)
    277c:	dcc00015 	stw	r19,0(sp)
    2780:	dfc00415 	stw	ra,16(sp)
   int len;
   int e;

   len = 0;
   while (*str)
   {
      if (in_loop_callback != NULL)
         (in_loop_callback)();

      e = eth_putchar(eth, ((*str) & 0xFF));
      if (e < 0)
         return (e);

      len++;
      str++;
    2784:	28800007 	ldb	r2,0(r5)
    2788:	2821883a 	mov	r16,r5
    278c:	2027883a 	mov	r19,r4
    2790:	3025883a 	mov	r18,r6
    2794:	0023883a 	mov	r17,zero
    2798:	10000a26 	beq	r2,zero,27c4 <eth_putstr+0x58>
    279c:	8c400044 	addi	r17,r17,1
    27a0:	90000126 	beq	r18,zero,27a8 <eth_putstr+0x3c>
    27a4:	903ee83a 	callr	r18
    27a8:	81400003 	ldbu	r5,0(r16)
    27ac:	9809883a 	mov	r4,r19
    27b0:	84000044 	addi	r16,r16,1
    27b4:	00027180 	call	2718 <eth_putchar>
    27b8:	10000316 	blt	r2,zero,27c8 <eth_putstr+0x5c>
    27bc:	80800007 	ldb	r2,0(r16)
    27c0:	003ff506 	br	2798 <eth_putstr+0x2c>
   }

   return (len);
    27c4:	8805883a 	mov	r2,r17
}
    27c8:	dfc00417 	ldw	ra,16(sp)
    27cc:	dc000317 	ldw	r16,12(sp)
    27d0:	dc400217 	ldw	r17,8(sp)
    27d4:	dc800117 	ldw	r18,4(sp)
    27d8:	dcc00017 	ldw	r19,0(sp)
    27dc:	dec00504 	addi	sp,sp,20
    27e0:	f800283a 	ret

000027e4 <eth_send>:


int eth_send(int eth, int addr, int port)
{
   int s;
   int REG1;

   REG1 = ETH_REG1 + ((eth & 0x7) << 6);
    27e4:	210001cc 	andi	r4,r4,7
    27e8:	200891ba 	slli	r4,r4,6
    27ec:	21021104 	addi	r4,r4,2116

   s = IORD_32DIRECT(REG1, 0);
    27f0:	21c00037 	ldwio	r7,0(r4)
   if ((s & 0x80008000) == 0x80008000)
   {
      // Ready + Enabled: send to eth_srcaddr/srcport
      IOWR_32DIRECT(REG1, 0, (s & ~0x000007FF) | (256)); // constant framelen
    27f4:	00be0004 	movi	r2,-2048
    27f8:	3884703a 	and	r2,r7,r2
    27fc:	12004014 	ori	r8,r2,256
    2800:	00a00074 	movhi	r2,32769
    2804:	10a00004 	addi	r2,r2,-32768
    2808:	3886703a 	and	r3,r7,r2
      s = IORD_32DIRECT(REG1, 0);
      IOWR_32DIRECT(REG1, 0, (s & ~0x00FF0000) | ((addr & 0xFF) << 16));
      s = IORD_32DIRECT(REG1, 0);
      IOWR_32DIRECT(REG1, 0, (s & ~0x0F000000) | ((port & 0x0F) << 24));
      //
      s = IORD_32DIRECT(REG1, 0);
      IOWR_32DIRECT(REG1, 0, (s & ~0x00007000));
      s = IORD_32DIRECT(REG1, 0);
      IOWR_32DIRECT(REG1, 0, (s |  0x00002000));
      return (0);
   }
   else
   {
      return (-1);
    280c:	01ffffc4 	movi	r7,-1
    2810:	1880191e 	bne	r3,r2,2878 <eth_send+0x94>
    2814:	22000035 	stwio	r8,0(r4)
    2818:	21c00037 	ldwio	r7,0(r4)
    281c:	00bfc074 	movhi	r2,65281
    2820:	10bfffc4 	addi	r2,r2,-1
    2824:	28c03fcc 	andi	r3,r5,255
    2828:	1806943a 	slli	r3,r3,16
    282c:	3884703a 	and	r2,r7,r2
    2830:	10c4b03a 	or	r2,r2,r3
    2834:	20800035 	stwio	r2,0(r4)
    2838:	21c00037 	ldwio	r7,0(r4)
    283c:	00bc4034 	movhi	r2,61696
    2840:	10bfffc4 	addi	r2,r2,-1
    2844:	30c003cc 	andi	r3,r6,15
    2848:	1806963a 	slli	r3,r3,24
    284c:	3884703a 	and	r2,r7,r2
    2850:	10c4b03a 	or	r2,r2,r3
    2854:	20800035 	stwio	r2,0(r4)
    2858:	21c00037 	ldwio	r7,0(r4)
    285c:	00a3ffc4 	movi	r2,-28673
    2860:	3884703a 	and	r2,r7,r2
    2864:	20800035 	stwio	r2,0(r4)
    2868:	21c00037 	ldwio	r7,0(r4)
    286c:	38880014 	ori	r2,r7,8192
    2870:	20800035 	stwio	r2,0(r4)
    2874:	000f883a 	mov	r7,zero
   }
}
    2878:	3805883a 	mov	r2,r7
    287c:	f800283a 	ret

00002880 <jtag_uart_getch>:


//
// jtag/rs232 high level getch() functions
//
// - data is locally accumulated until a complete line is received
// - main FSM applies a common parser logic for all interfaces:
//   data is processed one character at the time from the same
//   io_stream (getch() functions must generate a continuous
//   sequence of characters when a line is ready)
//
int jtag_uart_getch(void)
{
   static unsigned char buf[32];
   static int buflen;
   static int wrindex;
   static int rdindex;
   static int flagfull;
   int c;

   if (buflen <= 0)
    2880:	d0a00b17 	ldw	r2,-32724(gp)
    2884:	deffff04 	addi	sp,sp,-4
    2888:	dfc00015 	stw	ra,0(sp)
    288c:	00802316 	blt	zero,r2,291c <jtag_uart_getch+0x9c>
   {
      // empty buffer: jtag uart test
      c = alt_getch_jtag_uart();
    2890:	00020580 	call	2058 <alt_getch_jtag_uart>
    2894:	100b883a 	mov	r5,r2
      if (c >= 0)
    2898:	10002016 	blt	r2,zero,291c <jtag_uart_getch+0x9c>
      {
         if (wrindex < (sizeof(buf)/sizeof(buf[0])))
    289c:	d0e00c17 	ldw	r3,-32720(gp)
    28a0:	008007c4 	movi	r2,31
    28a4:	10c00736 	bltu	r2,r3,28c4 <jtag_uart_getch+0x44>
         {
            buf[wrindex++] = (unsigned char) c;
    28a8:	00800034 	movhi	r2,0
    28ac:	108d8d04 	addi	r2,r2,13876
    28b0:	1885883a 	add	r2,r3,r2
    28b4:	18c00044 	addi	r3,r3,1
    28b8:	11400005 	stb	r5,0(r2)
    28bc:	d0e00c15 	stw	r3,-32720(gp)
    28c0:	00000206 	br	28cc <jtag_uart_getch+0x4c>
         }
         else
         {
            flagfull = 1;
    28c4:	00800044 	movi	r2,1
    28c8:	d0a00e15 	stw	r2,-32712(gp)
         }

         if (c == 0 || c == '\n' || c == '\r')
    28cc:	28000426 	beq	r5,zero,28e0 <jtag_uart_getch+0x60>
    28d0:	00800284 	movi	r2,10
    28d4:	28800226 	beq	r5,r2,28e0 <jtag_uart_getch+0x60>
    28d8:	00800344 	movi	r2,13
    28dc:	28800b1e 	bne	r5,r2,290c <jtag_uart_getch+0x8c>
         {
            // end of line detected: buffer ready
            buflen = wrindex;
    28e0:	d0e00c17 	ldw	r3,-32720(gp)
            if (flagfull)
    28e4:	d0a00e17 	ldw	r2,-32712(gp)
    28e8:	d0e00b15 	stw	r3,-32724(gp)
    28ec:	10000426 	beq	r2,zero,2900 <jtag_uart_getch+0x80>
            {
               //// errfull indicator
               //buf[0] = '!';
               //buf[1] = '!';
               //buf[2] = '!';

               // errfull: forced end-of-line
               buf[wrindex - 1] = (unsigned char) c;
    28f0:	00800034 	movhi	r2,0
    28f4:	108d8cc4 	addi	r2,r2,13875
    28f8:	1885883a 	add	r2,r3,r2
    28fc:	11400005 	stb	r5,0(r2)
            }
            wrindex = 0;
    2900:	d0200c15 	stw	zero,-32720(gp)
            rdindex = 0;
    2904:	d0200d15 	stw	zero,-32716(gp)
            flagfull = 0;
    2908:	d0200e15 	stw	zero,-32712(gp)
         }

         // local echo for nios2-terminal
         alt_putch_jtag_uart(c, 0, NULL);
    290c:	2809883a 	mov	r4,r5
    2910:	000d883a 	mov	r6,zero
    2914:	000b883a 	mov	r5,zero
    2918:	00021740 	call	2174 <alt_putch_jtag_uart>
      }
   }

   if (buflen > 0)
    291c:	d1200b17 	ldw	r4,-32724(gp)
   {
      // getch from buffer
      buflen--;
      c = buf[rdindex++];
      return (c);
   }

   return (-1);
    2920:	00bfffc4 	movi	r2,-1
    2924:	01000a0e 	bge	zero,r4,2950 <jtag_uart_getch+0xd0>
    2928:	d0a00d17 	ldw	r2,-32716(gp)
    292c:	00c00034 	movhi	r3,0
    2930:	18cd8d04 	addi	r3,r3,13876
    2934:	213fffc4 	addi	r4,r4,-1
    2938:	10c7883a 	add	r3,r2,r3
    293c:	19400003 	ldbu	r5,0(r3)
    2940:	10800044 	addi	r2,r2,1
    2944:	d0a00d15 	stw	r2,-32716(gp)
    2948:	d1200b15 	stw	r4,-32724(gp)
    294c:	2805883a 	mov	r2,r5
}
    2950:	dfc00017 	ldw	ra,0(sp)
    2954:	dec00104 	addi	sp,sp,4
    2958:	f800283a 	ret

0000295c <rs232_uart_getch>:
//
//
int rs232_uart_getch(void)
{
   static unsigned char buf[32];
   static int buflen;
   static int wrindex;
   static int rdindex;
   static int flagfull;
   int nloop;
   int c;

   if (buflen <= 0)
    295c:	d0a00f17 	ldw	r2,-32708(gp)
    2960:	defffd04 	addi	sp,sp,-12
    2964:	dfc00215 	stw	ra,8(sp)
    2968:	dc000115 	stw	r16,4(sp)
    296c:	dc400015 	stw	r17,0(sp)
    2970:	00802516 	blt	zero,r2,2a08 <rs232_uart_getch+0xac>
   {
      // empty buffer: rs232 uart test
      nloop = alt_getch_rs232_uart(0);
    2974:	0009883a 	mov	r4,zero
    2978:	00020a00 	call	20a0 <alt_getch_rs232_uart>
    297c:	1021883a 	mov	r16,r2
      while (nloop > 0)
      {
         c = alt_getch_rs232_uart(1);
         if (c < 0)
            break;

         if (wrindex < (sizeof(buf)/sizeof(buf[0])))
         {
            buf[wrindex++] = (unsigned char) c;
         }
         else
         {
            flagfull = 1;
         }

         if (c == 0 || c == '\n' || c == '\r')
         {
            // end of line detected: buffer ready
            buflen = wrindex;
            if (flagfull)
            {
               //// errfull indicator
               //buf[0] = '!';
               //buf[1] = '!';
               //buf[2] = '!';

               // errfull: forced end-of-line
               buf[wrindex - 1] = (unsigned char) c;
            }
            wrindex = 0;
            rdindex = 0;
            flagfull = 0;
            break;
         }

         //// local echo for nios2-terminal
         //alt_putch_rs232_uart(c, 0, NULL);

         nloop--;
    2980:	0400210e 	bge	zero,r16,2a08 <rs232_uart_getch+0xac>
    2984:	04400044 	movi	r17,1
    2988:	8809883a 	mov	r4,r17
    298c:	00020a00 	call	20a0 <alt_getch_rs232_uart>
    2990:	100b883a 	mov	r5,r2
    2994:	10001c16 	blt	r2,zero,2a08 <rs232_uart_getch+0xac>
    2998:	d0a01017 	ldw	r2,-32704(gp)
    299c:	00c00034 	movhi	r3,0
    29a0:	18cd9504 	addi	r3,r3,13908
    29a4:	10cd883a 	add	r6,r2,r3
    29a8:	00c007c4 	movi	r3,31
    29ac:	1449883a 	add	r4,r2,r17
    29b0:	18800336 	bltu	r3,r2,29c0 <rs232_uart_getch+0x64>
    29b4:	31400005 	stb	r5,0(r6)
    29b8:	d1201015 	stw	r4,-32704(gp)
    29bc:	00000106 	br	29c4 <rs232_uart_getch+0x68>
    29c0:	d4601215 	stw	r17,-32696(gp)
    29c4:	843fffc4 	addi	r16,r16,-1
    29c8:	28000426 	beq	r5,zero,29dc <rs232_uart_getch+0x80>
    29cc:	00800284 	movi	r2,10
    29d0:	28800226 	beq	r5,r2,29dc <rs232_uart_getch+0x80>
    29d4:	00800344 	movi	r2,13
    29d8:	28bfe91e 	bne	r5,r2,2980 <rs232_uart_getch+0x24>
    29dc:	d0e01017 	ldw	r3,-32704(gp)
    29e0:	d0a01217 	ldw	r2,-32696(gp)
    29e4:	d0e00f15 	stw	r3,-32708(gp)
    29e8:	10000426 	beq	r2,zero,29fc <rs232_uart_getch+0xa0>
    29ec:	00800034 	movhi	r2,0
    29f0:	108d94c4 	addi	r2,r2,13907
    29f4:	1885883a 	add	r2,r3,r2
    29f8:	11400005 	stb	r5,0(r2)
    29fc:	d0201015 	stw	zero,-32704(gp)
    2a00:	d0201115 	stw	zero,-32700(gp)
    2a04:	d0201215 	stw	zero,-32696(gp)
      }
   }

   if (buflen > 0)
    2a08:	d1200f17 	ldw	r4,-32708(gp)
   {
      // getch from buffer
      buflen--;
      c = buf[rdindex++];
      return (c);
   }

   return (-1);
    2a0c:	00bfffc4 	movi	r2,-1
    2a10:	01000a0e 	bge	zero,r4,2a3c <rs232_uart_getch+0xe0>
    2a14:	d0a01117 	ldw	r2,-32700(gp)
    2a18:	00c00034 	movhi	r3,0
    2a1c:	18cd9504 	addi	r3,r3,13908
    2a20:	213fffc4 	addi	r4,r4,-1
    2a24:	10c7883a 	add	r3,r2,r3
    2a28:	19400003 	ldbu	r5,0(r3)
    2a2c:	10800044 	addi	r2,r2,1
    2a30:	d0a01115 	stw	r2,-32700(gp)
    2a34:	d1200f15 	stw	r4,-32708(gp)
    2a38:	2805883a 	mov	r2,r5
}
    2a3c:	dfc00217 	ldw	ra,8(sp)
    2a40:	dc000117 	ldw	r16,4(sp)
    2a44:	dc400017 	ldw	r17,0(sp)
    2a48:	dec00304 	addi	sp,sp,12
    2a4c:	f800283a 	ret

00002a50 <output_putchar>:


int output_putchar(int c)
{
   int e;

   e = 0;

   if (io_stream == 0)
    2a50:	d0e01317 	ldw	r3,-32692(gp)
    2a54:	defffe04 	addi	sp,sp,-8
    2a58:	dc000015 	stw	r16,0(sp)
    2a5c:	dfc00115 	stw	ra,4(sp)
   {
      /* jtag_uart selected: blocking putch() */
      // NOTE: we use a blocking putch() to guarantee complete data transmission
      // when slow jtag_uart interface and tx hardware buffer is full
      e = alt_putch_jtag_uart(c, 1, &idle_function);
    2a60:	01800034 	movhi	r6,0
    2a64:	31899804 	addi	r6,r6,9824
    2a68:	01400044 	movi	r5,1
    2a6c:	2021883a 	mov	r16,r4
    2a70:	0011883a 	mov	r8,zero
    2a74:	1800021e 	bne	r3,zero,2a80 <output_putchar+0x30>
    2a78:	00021740 	call	2174 <alt_putch_jtag_uart>
    2a7c:	00000706 	br	2a9c <output_putchar+0x4c>

      /* echo */
      if (echo_flag)
         e = eth_putchar(echo_eth, c);
   }
   else if (io_stream == 1)
    2a80:	00800044 	movi	r2,1
   {
      /* rs232_uart selected: blocking putch() */
      // NOTE: we must use a blocking putch() because rs232_uart does not have any
      // form of transmission buffer
      e = alt_putch_rs232_uart(c, 1, &idle_function);
    2a84:	180b883a 	mov	r5,r3
    2a88:	01800034 	movhi	r6,0
    2a8c:	31899804 	addi	r6,r6,9824

      /* echo */
      if (echo_flag)
         e = eth_putchar(echo_eth, c);
   }
   else if (io_stream >= 2 && io_stream <= 9)
    2a90:	19ffff84 	addi	r7,r3,-2
    2a94:	1880071e 	bne	r3,r2,2ab4 <output_putchar+0x64>
    2a98:	000221c0 	call	221c <alt_putch_rs232_uart>
    2a9c:	1011883a 	mov	r8,r2
    2aa0:	d0a01d17 	ldw	r2,-32652(gp)
    2aa4:	800b883a 	mov	r5,r16
    2aa8:	10000826 	beq	r2,zero,2acc <output_putchar+0x7c>
    2aac:	d1201e17 	ldw	r4,-32648(gp)
    2ab0:	00000406 	br	2ac4 <output_putchar+0x74>
    2ab4:	008001c4 	movi	r2,7
   {
      /* eth interface selected: non-blocking putchar() */
      // NOTE: all functions eth_putchar/eth_putstr are non-blocking by
      // default (eth interface has big rx/tx buffers and we assume txport
      // always ready --> when txport not ready or buffer full condition data
      // is simply discarded)
      e = eth_putchar(io_stream - 2, c);
    2ab8:	3809883a 	mov	r4,r7
    2abc:	800b883a 	mov	r5,r16
    2ac0:	11c00236 	bltu	r2,r7,2acc <output_putchar+0x7c>
    2ac4:	00027180 	call	2718 <eth_putchar>
    2ac8:	1011883a 	mov	r8,r2
   }

   return (e);
}
    2acc:	4005883a 	mov	r2,r8
    2ad0:	dfc00117 	ldw	ra,4(sp)
    2ad4:	dc000017 	ldw	r16,0(sp)
    2ad8:	dec00204 	addi	sp,sp,8
    2adc:	f800283a 	ret

00002ae0 <output_putstr>:


int output_putstr(char *s)
{
   int e;

   e = 0;

   if (io_stream == 0)
    2ae0:	d0a01317 	ldw	r2,-32692(gp)
    2ae4:	defffe04 	addi	sp,sp,-8
    2ae8:	dc000015 	stw	r16,0(sp)
    2aec:	dfc00115 	stw	ra,4(sp)
   {
      e = alt_putstr_jtag_uart(s, 1, &idle_function);
    2af0:	01400044 	movi	r5,1
    2af4:	01800034 	movhi	r6,0
    2af8:	31899804 	addi	r6,r6,9824
    2afc:	2021883a 	mov	r16,r4
    2b00:	000f883a 	mov	r7,zero
    2b04:	10000a1e 	bne	r2,zero,2b30 <output_putstr+0x50>
    2b08:	00022c40 	call	22c4 <alt_putstr_jtag_uart>
    2b0c:	100f883a 	mov	r7,r2

      /* echo */
      if (echo_flag)
    2b10:	d0a01d17 	ldw	r2,-32652(gp)
         e = eth_putstr(echo_eth, s, &idle_function);
    2b14:	800b883a 	mov	r5,r16
    2b18:	01800034 	movhi	r6,0
    2b1c:	31899804 	addi	r6,r6,9824
    2b20:	10000326 	beq	r2,zero,2b30 <output_putstr+0x50>
    2b24:	d1201e17 	ldw	r4,-32648(gp)
    2b28:	000276c0 	call	276c <eth_putstr>
    2b2c:	100f883a 	mov	r7,r2
   }
   if (io_stream == 1)
    2b30:	d0e01317 	ldw	r3,-32692(gp)
    2b34:	00800044 	movi	r2,1
   {
      e = alt_putstr_rs232_uart(s, 1, &idle_function);
    2b38:	8009883a 	mov	r4,r16
    2b3c:	01800034 	movhi	r6,0
    2b40:	31899804 	addi	r6,r6,9824
    2b44:	180b883a 	mov	r5,r3
    2b48:	18800a1e 	bne	r3,r2,2b74 <output_putstr+0x94>
    2b4c:	000236c0 	call	236c <alt_putstr_rs232_uart>
    2b50:	100f883a 	mov	r7,r2

      /* echo */
      if (echo_flag)
    2b54:	d0a01d17 	ldw	r2,-32652(gp)
         e = eth_putstr(echo_eth, s, &idle_function);
    2b58:	800b883a 	mov	r5,r16
    2b5c:	01800034 	movhi	r6,0
    2b60:	31899804 	addi	r6,r6,9824
    2b64:	10000326 	beq	r2,zero,2b74 <output_putstr+0x94>
    2b68:	d1201e17 	ldw	r4,-32648(gp)
    2b6c:	000276c0 	call	276c <eth_putstr>
    2b70:	100f883a 	mov	r7,r2
   }
   if (io_stream >= 2 && io_stream <= 9)
    2b74:	d0a01317 	ldw	r2,-32692(gp)
    2b78:	00c001c4 	movi	r3,7
   {
      e = eth_putstr(io_stream - 2, s, &idle_function);
    2b7c:	800b883a 	mov	r5,r16
    2b80:	10bfff84 	addi	r2,r2,-2
    2b84:	01800034 	movhi	r6,0
    2b88:	31899804 	addi	r6,r6,9824
    2b8c:	1009883a 	mov	r4,r2
    2b90:	18800236 	bltu	r3,r2,2b9c <output_putstr+0xbc>
    2b94:	000276c0 	call	276c <eth_putstr>
    2b98:	100f883a 	mov	r7,r2
   }

   return (e);
}
    2b9c:	3805883a 	mov	r2,r7
    2ba0:	dfc00117 	ldw	ra,4(sp)
    2ba4:	dc000017 	ldw	r16,0(sp)
    2ba8:	dec00204 	addi	sp,sp,8
    2bac:	f800283a 	ret

00002bb0 <output_send>:


int output_send(void)
{
   int e = 0;

   if (io_stream == 0 || io_stream == 1)
    2bb0:	d0e01317 	ldw	r3,-32692(gp)
    2bb4:	defffe04 	addi	sp,sp,-8
    2bb8:	00800044 	movi	r2,1
    2bbc:	dc000015 	stw	r16,0(sp)
    2bc0:	dfc00115 	stw	ra,4(sp)
   {
      // uart terminator/prompt
      output_putstr("ready\n");
    2bc4:	01000034 	movhi	r4,0
    2bc8:	210d0704 	addi	r4,r4,13340
      // uart-echo send
      if (echo_flag)
         e = eth_send(echo_eth, echo_addr, echo_port);
   }
   else if (io_stream >= 2 && io_stream <= 9)
    2bcc:	197fff84 	addi	r5,r3,-2
    2bd0:	0021883a 	mov	r16,zero
    2bd4:	10c00736 	bltu	r2,r3,2bf4 <output_send+0x44>
    2bd8:	0002ae00 	call	2ae0 <output_putstr>
    2bdc:	d0a01d17 	ldw	r2,-32652(gp)
    2be0:	10000b26 	beq	r2,zero,2c10 <output_send+0x60>
    2be4:	d1201e17 	ldw	r4,-32648(gp)
    2be8:	d1601f17 	ldw	r5,-32644(gp)
    2bec:	d1a02017 	ldw	r6,-32640(gp)
    2bf0:	00000506 	br	2c08 <output_send+0x58>
    2bf4:	008001c4 	movi	r2,7
   {
      // eth send
      e = eth_send(io_stream - 2, eth_srcaddr, eth_srcport);
    2bf8:	2809883a 	mov	r4,r5
    2bfc:	11400436 	bltu	r2,r5,2c10 <output_send+0x60>
    2c00:	d1602117 	ldw	r5,-32636(gp)
    2c04:	d1a02217 	ldw	r6,-32632(gp)
    2c08:	00027e40 	call	27e4 <eth_send>
    2c0c:	1021883a 	mov	r16,r2
   }

   return (e);
}
    2c10:	8005883a 	mov	r2,r16
    2c14:	dfc00117 	ldw	ra,4(sp)
    2c18:	dc000017 	ldw	r16,0(sp)
    2c1c:	dec00204 	addi	sp,sp,8
    2c20:	f800283a 	ret

00002c24 <msnibble>:


int msnibble(int n)
{
   n = (n >> 28) & 0xF;
    2c24:	2008d73a 	srli	r4,r4,28
   if (n >= 0xA && n <= 0xF)
    2c28:	00800144 	movi	r2,5
    2c2c:	20fffd84 	addi	r3,r4,-10
      return ('A' + n - 0xA);
    2c30:	21400dc4 	addi	r5,r4,55
    2c34:	10c0012e 	bgeu	r2,r3,2c3c <msnibble+0x18>
   return ('0' + n);
    2c38:	21400c04 	addi	r5,r4,48

   /*
   n = n & 0xF0000000;
   if (n == 0xF0000000) return 'F';
   if (n == 0xE0000000) return 'E';
   if (n == 0xD0000000) return 'D';
   if (n == 0xC0000000) return 'C';
   if (n == 0xB0000000) return 'B';
   if (n == 0xA0000000) return 'A';
   if (n == 0x90000000) return '9';
   if (n == 0x80000000) return '8';
   if (n == 0x70000000) return '7';
   if (n == 0x60000000) return '6';
   if (n == 0x50000000) return '5';
   if (n == 0x40000000) return '4';
   if (n == 0x30000000) return '3';
   if (n == 0x20000000) return '2';
   if (n == 0x10000000) return '1';
   return '0';
   */
}
    2c3c:	2805883a 	mov	r2,r5
    2c40:	f800283a 	ret

00002c44 <printhex>:


void printhex(int n, int len)
{
    2c44:	defffc04 	addi	sp,sp,-16
    2c48:	dc000215 	stw	r16,8(sp)
    2c4c:	dc400115 	stw	r17,4(sp)
    2c50:	dc800015 	stw	r18,0(sp)
    2c54:	dfc00315 	stw	ra,12(sp)
    2c58:	2021883a 	mov	r16,r4
    2c5c:	2825883a 	mov	r18,r5
   /*
   output_putchar(msnibble(n <<  0));
   output_putchar(msnibble(n <<  4));
   output_putchar(msnibble(n <<  8));
   output_putchar(msnibble(n << 12));
   output_putchar(msnibble(n << 16));
   output_putchar(msnibble(n << 20));
   output_putchar(msnibble(n << 24));
   output_putchar(msnibble(n << 28));
   */

   int i;

   for (i = 8; i > 0; i--)
    2c60:	04400204 	movi	r17,8
   {
      if (i <= len)
         output_putchar(msnibble(n));
    2c64:	8009883a 	mov	r4,r16

      n = n << 4;
    2c68:	8020913a 	slli	r16,r16,4
    2c6c:	94400316 	blt	r18,r17,2c7c <printhex+0x38>
    2c70:	0002c240 	call	2c24 <msnibble>
    2c74:	1009883a 	mov	r4,r2
    2c78:	0002a500 	call	2a50 <output_putchar>
    2c7c:	8c7fffc4 	addi	r17,r17,-1
    2c80:	047ff816 	blt	zero,r17,2c64 <printhex+0x20>
    2c84:	dfc00317 	ldw	ra,12(sp)
    2c88:	dc000217 	ldw	r16,8(sp)
    2c8c:	dc400117 	ldw	r17,4(sp)
    2c90:	dc800017 	ldw	r18,0(sp)
    2c94:	dec00404 	addi	sp,sp,16
    2c98:	f800283a 	ret

00002c9c <cmdread>:
   }
}

/*********************************************************************/
/*********************************************************************/

int cmdread(void)
{
   int e = 0;

   if (cmd1 == '1')
    2c9c:	d0e01a17 	ldw	r3,-32664(gp)
    2ca0:	defffe04 	addi	sp,sp,-8
    2ca4:	00800c44 	movi	r2,49
    2ca8:	dc000015 	stw	r16,0(sp)
    2cac:	dfc00115 	stw	ra,4(sp)
    2cb0:	0021883a 	mov	r16,zero
    2cb4:	1880051e 	bne	r3,r2,2ccc <cmdread+0x30>
   {
      rdata = IORD_8DIRECT(arg[0], 0);
    2cb8:	00800034 	movhi	r2,0
    2cbc:	108d9d04 	addi	r2,r2,13940
    2cc0:	10800017 	ldw	r2,0(r2)
    2cc4:	10800023 	ldbuio	r2,0(r2)
    2cc8:	00001006 	br	2d0c <cmdread+0x70>
   }
   else if (cmd1 == '2')
    2ccc:	00800c84 	movi	r2,50
    2cd0:	1880051e 	bne	r3,r2,2ce8 <cmdread+0x4c>
   {
      rdata = IORD_16DIRECT(arg[0], 0);
    2cd4:	00800034 	movhi	r2,0
    2cd8:	108d9d04 	addi	r2,r2,13940
    2cdc:	10800017 	ldw	r2,0(r2)
    2ce0:	1080002b 	ldhuio	r2,0(r2)
    2ce4:	00000906 	br	2d0c <cmdread+0x70>
   }
   else if (cmd1 == '4')
    2ce8:	00800d04 	movi	r2,52
    2cec:	1880051e 	bne	r3,r2,2d04 <cmdread+0x68>
   {
      rdata = IORD_32DIRECT(arg[0], 0);
    2cf0:	00800034 	movhi	r2,0
    2cf4:	108d9d04 	addi	r2,r2,13940
    2cf8:	10800017 	ldw	r2,0(r2)
    2cfc:	10800037 	ldwio	r2,0(r2)
    2d00:	00000206 	br	2d0c <cmdread+0x70>
   }
   else
   {
      e = -1;
    2d04:	043fffc4 	movi	r16,-1
    2d08:	00001906 	br	2d70 <cmdread+0xd4>
   }

   if (e == 0)
   {
      output_putchar('\n');
    2d0c:	01000284 	movi	r4,10
    2d10:	d0a01815 	stw	r2,-32672(gp)
    2d14:	0002a500 	call	2a50 <output_putchar>
      output_putchar(cmd0);
    2d18:	d1201917 	ldw	r4,-32668(gp)
    2d1c:	0002a500 	call	2a50 <output_putchar>
      output_putchar(cmd1);
    2d20:	d1201a17 	ldw	r4,-32664(gp)
    2d24:	0002a500 	call	2a50 <output_putchar>
      output_putstr(" = 0x");
    2d28:	01000034 	movhi	r4,0
    2d2c:	210d0904 	addi	r4,r4,13348
    2d30:	0002ae00 	call	2ae0 <output_putstr>
      printhex(rdata, 8);
    2d34:	d1201817 	ldw	r4,-32672(gp)
    2d38:	01400204 	movi	r5,8
    2d3c:	0002c440 	call	2c44 <printhex>
      output_putstr(" (Addr = 0x");
    2d40:	01000034 	movhi	r4,0
    2d44:	210d0b04 	addi	r4,r4,13356
    2d48:	0002ae00 	call	2ae0 <output_putstr>
      printhex(arg[0], 8);
    2d4c:	00800034 	movhi	r2,0
    2d50:	108d9d04 	addi	r2,r2,13940
    2d54:	11000017 	ldw	r4,0(r2)
    2d58:	01400204 	movi	r5,8
    2d5c:	0002c440 	call	2c44 <printhex>
      output_putstr(")\n");
    2d60:	01000034 	movhi	r4,0
    2d64:	210d0e04 	addi	r4,r4,13368
    2d68:	0002ae00 	call	2ae0 <output_putstr>
      output_send();
    2d6c:	0002bb00 	call	2bb0 <output_send>
   }

   //output_send();
   return (e);
}
    2d70:	8005883a 	mov	r2,r16
    2d74:	dfc00117 	ldw	ra,4(sp)
    2d78:	dc000017 	ldw	r16,0(sp)
    2d7c:	dec00204 	addi	sp,sp,8
    2d80:	f800283a 	ret

00002d84 <cmdwrite>:


int cmdwrite(void)
{
   int e = 0;

   if (cmd1 == '1')
    2d84:	d0e01a17 	ldw	r3,-32664(gp)
    2d88:	defffd04 	addi	sp,sp,-12
    2d8c:	00800c44 	movi	r2,49
    2d90:	dc400015 	stw	r17,0(sp)
    2d94:	dfc00215 	stw	ra,8(sp)
    2d98:	dc000115 	stw	r16,4(sp)
   {
      IOWR_8DIRECT(arg[0], 0, arg[1]);
    2d9c:	01000034 	movhi	r4,0
    2da0:	210d9d04 	addi	r4,r4,13940
    2da4:	0023883a 	mov	r17,zero
    2da8:	1880041e 	bne	r3,r2,2dbc <cmdwrite+0x38>
    2dac:	20c00117 	ldw	r3,4(r4)
    2db0:	20800017 	ldw	r2,0(r4)
    2db4:	10c00025 	stbio	r3,0(r2)
    2db8:	00001206 	br	2e04 <cmdwrite+0x80>
   }
   else if (cmd1 == '2')
    2dbc:	00800c84 	movi	r2,50
   {
      IOWR_16DIRECT(arg[0], 0, arg[1]);
    2dc0:	01000034 	movhi	r4,0
    2dc4:	210d9d04 	addi	r4,r4,13940
    2dc8:	1880041e 	bne	r3,r2,2ddc <cmdwrite+0x58>
    2dcc:	20c00117 	ldw	r3,4(r4)
    2dd0:	20800017 	ldw	r2,0(r4)
    2dd4:	10c0002d 	sthio	r3,0(r2)
    2dd8:	00000a06 	br	2e04 <cmdwrite+0x80>
   }
   else if (cmd1 == '4')
    2ddc:	00800d04 	movi	r2,52
   {
      IOWR_32DIRECT(arg[0], 0, arg[1]);
    2de0:	01000034 	movhi	r4,0
    2de4:	210d9d04 	addi	r4,r4,13940
    2de8:	1880041e 	bne	r3,r2,2dfc <cmdwrite+0x78>
    2dec:	20c00117 	ldw	r3,4(r4)
    2df0:	20800017 	ldw	r2,0(r4)
    2df4:	10c00035 	stwio	r3,0(r2)
    2df8:	00000206 	br	2e04 <cmdwrite+0x80>
   }
   else
   {
      e = -1;
    2dfc:	047fffc4 	movi	r17,-1
    2e00:	00001706 	br	2e60 <cmdwrite+0xdc>
   }

   if (e == 0)
   {
      output_putchar('\n');
    2e04:	01000284 	movi	r4,10
    2e08:	0002a500 	call	2a50 <output_putchar>
      output_putchar(cmd0);
    2e0c:	d1201917 	ldw	r4,-32668(gp)
      output_putchar(cmd1);
      output_putstr(" = 0x");
      printhex(arg[1], 8);
    2e10:	04000034 	movhi	r16,0
    2e14:	840d9d04 	addi	r16,r16,13940
    2e18:	0002a500 	call	2a50 <output_putchar>
    2e1c:	d1201a17 	ldw	r4,-32664(gp)
    2e20:	0002a500 	call	2a50 <output_putchar>
    2e24:	01000034 	movhi	r4,0
    2e28:	210d0904 	addi	r4,r4,13348
    2e2c:	0002ae00 	call	2ae0 <output_putstr>
    2e30:	81000117 	ldw	r4,4(r16)
    2e34:	01400204 	movi	r5,8
    2e38:	0002c440 	call	2c44 <printhex>
      output_putstr(" (Addr = 0x");
    2e3c:	01000034 	movhi	r4,0
    2e40:	210d0b04 	addi	r4,r4,13356
    2e44:	0002ae00 	call	2ae0 <output_putstr>
      printhex(arg[0], 8);
    2e48:	81000017 	ldw	r4,0(r16)
    2e4c:	01400204 	movi	r5,8
    2e50:	0002c440 	call	2c44 <printhex>
      output_putstr(")\n");
    2e54:	01000034 	movhi	r4,0
    2e58:	210d0e04 	addi	r4,r4,13368
    2e5c:	0002ae00 	call	2ae0 <output_putstr>
   }

   output_send();
    2e60:	0002bb00 	call	2bb0 <output_send>
   return (e);
}
    2e64:	8805883a 	mov	r2,r17
    2e68:	dfc00217 	ldw	ra,8(sp)
    2e6c:	dc000117 	ldw	r16,4(sp)
    2e70:	dc400017 	ldw	r17,0(sp)
    2e74:	dec00304 	addi	sp,sp,12
    2e78:	f800283a 	ret

00002e7c <cmdecho>:


int cmdecho(void)
{
   int e = 0;

   if (cmd1 == '0' || (cmd1 == '1' && (narg == 0 || narg == 3)))
    2e7c:	d1201a17 	ldw	r4,-32664(gp)
    2e80:	defffe04 	addi	sp,sp,-8
    2e84:	00800c04 	movi	r2,48
    2e88:	dc000015 	stw	r16,0(sp)
    2e8c:	dfc00115 	stw	ra,4(sp)
    2e90:	0021883a 	mov	r16,zero
    2e94:	20800626 	beq	r4,r2,2eb0 <cmdecho+0x34>
    2e98:	00800c44 	movi	r2,49
    2e9c:	2080351e 	bne	r4,r2,2f74 <cmdecho+0xf8>
    2ea0:	d0e01617 	ldw	r3,-32680(gp)
    2ea4:	18000226 	beq	r3,zero,2eb0 <cmdecho+0x34>
    2ea8:	008000c4 	movi	r2,3
    2eac:	1880311e 	bne	r3,r2,2f74 <cmdecho+0xf8>
   {
      if (cmd1 == '0')
    2eb0:	00800c04 	movi	r2,48
    2eb4:	2080041e 	bne	r4,r2,2ec8 <cmdecho+0x4c>
      {
         // echo OFF
         echo_flag = 0;
         output_putstr("\nE0 : ECHO OFF");
    2eb8:	01000034 	movhi	r4,0
    2ebc:	210d0f04 	addi	r4,r4,13372
    2ec0:	d0201d15 	stw	zero,-32652(gp)
    2ec4:	00001306 	br	2f14 <cmdecho+0x98>
      }
      else if (cmd1 == '1')
    2ec8:	00800c44 	movi	r2,49
    2ecc:	2080121e 	bne	r4,r2,2f18 <cmdecho+0x9c>
      {
         // echo ON
         echo_flag = 1;
         if (narg == 3)
    2ed0:	d0e01617 	ldw	r3,-32680(gp)
    2ed4:	00800044 	movi	r2,1
    2ed8:	d0a01d15 	stw	r2,-32652(gp)
    2edc:	008000c4 	movi	r2,3
    2ee0:	18800a1e 	bne	r3,r2,2f0c <cmdecho+0x90>
         {
            // echo params updated
            echo_eth  = arg[0] & 0x7;
    2ee4:	00800034 	movhi	r2,0
    2ee8:	108d9d04 	addi	r2,r2,13940
            echo_addr = arg[1] & 0xFF;
            echo_port = arg[2] & 0xF;
    2eec:	11000217 	ldw	r4,8(r2)
    2ef0:	10c00017 	ldw	r3,0(r2)
    2ef4:	10800103 	ldbu	r2,4(r2)
    2ef8:	210003cc 	andi	r4,r4,15
    2efc:	18c001cc 	andi	r3,r3,7
    2f00:	d0e01e15 	stw	r3,-32648(gp)
    2f04:	d0a01f15 	stw	r2,-32644(gp)
    2f08:	d1202015 	stw	r4,-32640(gp)
         }
         output_putstr("\nE1 : ECHO ON");
    2f0c:	01000034 	movhi	r4,0
    2f10:	210d1304 	addi	r4,r4,13388
    2f14:	0002ae00 	call	2ae0 <output_putstr>
      }
      // echo params
      output_putstr(" (eth=0x");
    2f18:	01000034 	movhi	r4,0
    2f1c:	210d1704 	addi	r4,r4,13404
    2f20:	0002ae00 	call	2ae0 <output_putstr>
      printhex(echo_eth, 1);
    2f24:	d1201e17 	ldw	r4,-32648(gp)
    2f28:	01400044 	movi	r5,1
    2f2c:	0002c440 	call	2c44 <printhex>
      output_putstr(",addr=0x");
    2f30:	01000034 	movhi	r4,0
    2f34:	210d1a04 	addi	r4,r4,13416
    2f38:	0002ae00 	call	2ae0 <output_putstr>
      printhex(echo_addr, 2);
    2f3c:	d1201f17 	ldw	r4,-32644(gp)
    2f40:	01400084 	movi	r5,2
    2f44:	0002c440 	call	2c44 <printhex>
      output_putstr(",port=0x");
    2f48:	01000034 	movhi	r4,0
    2f4c:	210d1d04 	addi	r4,r4,13428
    2f50:	0002ae00 	call	2ae0 <output_putstr>
      printhex(echo_port, 1);
    2f54:	d1202017 	ldw	r4,-32640(gp)
    2f58:	01400044 	movi	r5,1
    2f5c:	0002c440 	call	2c44 <printhex>
      output_putstr(")\n");
    2f60:	01000034 	movhi	r4,0
    2f64:	210d0e04 	addi	r4,r4,13368
    2f68:	0002ae00 	call	2ae0 <output_putstr>
      output_send();
    2f6c:	0002bb00 	call	2bb0 <output_send>
    2f70:	00000106 	br	2f78 <cmdecho+0xfc>
   }
   else
      e = -1;
    2f74:	043fffc4 	movi	r16,-1

   return (e);
}
    2f78:	8005883a 	mov	r2,r16
    2f7c:	dfc00117 	ldw	ra,4(sp)
    2f80:	dc000017 	ldw	r16,0(sp)
    2f84:	dec00204 	addi	sp,sp,8
    2f88:	f800283a 	ret

00002f8c <header>:


void header(void)
{
    2f8c:	deffff04 	addi	sp,sp,-4
   output_putstr("Hello from Nios II!\n");
    2f90:	01000034 	movhi	r4,0
    2f94:	210d2004 	addi	r4,r4,13440
    2f98:	dfc00015 	stw	ra,0(sp)
    2f9c:	0002ae00 	call	2ae0 <output_putstr>
   output_putstr("Avalon r/w interface (v1.0):\n\n");
    2fa0:	01000034 	movhi	r4,0
    2fa4:	210d2604 	addi	r4,r4,13464
    2fa8:	0002ae00 	call	2ae0 <output_putstr>
   output_putstr("{R1|R2|R4} {addr}        --> Rn = Read 1|2|4 bytes\n");
    2fac:	01000034 	movhi	r4,0
    2fb0:	210d2e04 	addi	r4,r4,13496
    2fb4:	0002ae00 	call	2ae0 <output_putstr>
   output_putstr("{W1|W2|W4} {addr} {data} --> Wn = Write 1|2|4 bytes\n");
    2fb8:	01000034 	movhi	r4,0
    2fbc:	210d3b04 	addi	r4,r4,13548
    2fc0:	0002ae00 	call	2ae0 <output_putstr>
   output_putstr("{E0}|{E1 eth addr port}  --> ETH ECHO On/Off\n");
    2fc4:	01000034 	movhi	r4,0
    2fc8:	210d4904 	addi	r4,r4,13604
    2fcc:	0002ae00 	call	2ae0 <output_putstr>
   output_send();
    2fd0:	02000034 	movhi	r8,0
    2fd4:	420aec04 	addi	r8,r8,11184
    2fd8:	dfc00017 	ldw	ra,0(sp)
    2fdc:	dec00104 	addi	sp,sp,4
    2fe0:	4000683a 	jmp	r8

00002fe4 <cmdexec>:
}


int cmdexec(void)
{
   int e = -1;

   if (sts == 0)
    2fe4:	d0e01417 	ldw	r3,-32688(gp)
    2fe8:	defffe04 	addi	sp,sp,-8
    2fec:	dc000015 	stw	r16,0(sp)
    2ff0:	dfc00115 	stw	ra,4(sp)
    2ff4:	043fffc4 	movi	r16,-1
    2ff8:	1800051e 	bne	r3,zero,3010 <cmdexec+0x2c>
   {
      // nop
      output_putstr("nop\n");
    2ffc:	01000034 	movhi	r4,0
    3000:	210d5504 	addi	r4,r4,13652
    3004:	0002ae00 	call	2ae0 <output_putstr>
      output_send();
      e = 0;
    3008:	0021883a 	mov	r16,zero
    300c:	00003406 	br	30e0 <cmdexec+0xfc>
   }
   else if (sts == 99 + 2)
    3010:	00801944 	movi	r2,101
    3014:	18802f26 	beq	r3,r2,30d4 <cmdexec+0xf0>
   {
      // standard command with invalid char on args: command not executed
   }
   else if ((cmd0 == 'r' || cmd0 == 'R') && (cmd1 == '1' || cmd1 == '2' || cmd1 == '4'))
    3018:	d1201917 	ldw	r4,-32668(gp)
    301c:	00801c84 	movi	r2,114
    3020:	20800226 	beq	r4,r2,302c <cmdexec+0x48>
    3024:	00801484 	movi	r2,82
    3028:	20800a1e 	bne	r4,r2,3054 <cmdexec+0x70>
    302c:	d0e01a17 	ldw	r3,-32664(gp)
    3030:	01400044 	movi	r5,1
    3034:	18bff3c4 	addi	r2,r3,-49
    3038:	2880022e 	bgeu	r5,r2,3044 <cmdexec+0x60>
    303c:	00800d04 	movi	r2,52
    3040:	1880041e 	bne	r3,r2,3054 <cmdexec+0x70>
   {
      if (narg == 1)
    3044:	d0a01617 	ldw	r2,-32680(gp)
    3048:	1140221e 	bne	r2,r5,30d4 <cmdexec+0xf0>
      {
         e = cmdread();
    304c:	0002c9c0 	call	2c9c <cmdread>
    3050:	00001e06 	br	30cc <cmdexec+0xe8>
      }
   }
   else if ((cmd0 == 'w' || cmd0 == 'W') && (cmd1 == '1' || cmd1 == '2' || cmd1 == '4'))
    3054:	00801dc4 	movi	r2,119
    3058:	20800226 	beq	r4,r2,3064 <cmdexec+0x80>
    305c:	008015c4 	movi	r2,87
    3060:	20800b1e 	bne	r4,r2,3090 <cmdexec+0xac>
    3064:	d1601a17 	ldw	r5,-32664(gp)
    3068:	00800044 	movi	r2,1
    306c:	28fff3c4 	addi	r3,r5,-49
    3070:	10c0022e 	bgeu	r2,r3,307c <cmdexec+0x98>
    3074:	00800d04 	movi	r2,52
    3078:	2880051e 	bne	r5,r2,3090 <cmdexec+0xac>
   {
      if (narg == 2)
    307c:	d0e01617 	ldw	r3,-32680(gp)
    3080:	00800084 	movi	r2,2
    3084:	1880131e 	bne	r3,r2,30d4 <cmdexec+0xf0>
      {
         e = cmdwrite();
    3088:	0002d840 	call	2d84 <cmdwrite>
    308c:	00000f06 	br	30cc <cmdexec+0xe8>
      }
   }
   else if ((cmd0 == 'e' || cmd0 == 'E') && (cmd1 == '0' || cmd1 == '1'))
    3090:	00801944 	movi	r2,101
    3094:	20800226 	beq	r4,r2,30a0 <cmdexec+0xbc>
    3098:	00801144 	movi	r2,69
    309c:	2080061e 	bne	r4,r2,30b8 <cmdexec+0xd4>
    30a0:	d0a01a17 	ldw	r2,-32664(gp)
    30a4:	00c00044 	movi	r3,1
    30a8:	10bff404 	addi	r2,r2,-48
    30ac:	18800236 	bltu	r3,r2,30b8 <cmdexec+0xd4>
   {
      e = cmdecho();
    30b0:	0002e7c0 	call	2e7c <cmdecho>
    30b4:	00000506 	br	30cc <cmdexec+0xe8>
   }
   else if (cmd0 == '?')
    30b8:	00800fc4 	movi	r2,63
    30bc:	2080051e 	bne	r4,r2,30d4 <cmdexec+0xf0>
   {
      header();
    30c0:	0002f8c0 	call	2f8c <header>
      e = 0;
    30c4:	0021883a 	mov	r16,zero
    30c8:	00000606 	br	30e4 <cmdexec+0x100>
    30cc:	1021883a 	mov	r16,r2
   }

   if (e)
    30d0:	10000426 	beq	r2,zero,30e4 <cmdexec+0x100>
   {
      output_putstr("???\n");
    30d4:	01000034 	movhi	r4,0
    30d8:	210d5704 	addi	r4,r4,13660
    30dc:	0002ae00 	call	2ae0 <output_putstr>
      output_send();
    30e0:	0002bb00 	call	2bb0 <output_send>
   }

   return (e);
}
    30e4:	8005883a 	mov	r2,r16
    30e8:	dfc00117 	ldw	ra,4(sp)
    30ec:	dc000017 	ldw	r16,0(sp)
    30f0:	dec00204 	addi	sp,sp,8
    30f4:	f800283a 	ret

000030f8 <main>:

/*********************************************************************/
/*********************************************************************/

int main()
{
    30f8:	defffe04 	addi	sp,sp,-8
    30fc:	dfc00115 	stw	ra,4(sp)
    3100:	dc000015 	stw	r16,0(sp)
   int c;
   int blank;

   // init commands
   cmdinit();
    3104:	00025780 	call	2578 <cmdinit>

   // hello msg
   header();
    3108:	0002f8c0 	call	2f8c <header>

   // main endless loop
   while (1)
   {
 	   // getchar loop
      do
 	   {
         idle_function();
    310c:	00026600 	call	2660 <idle_function>

         if (io_stream == 0)
    3110:	d1201317 	ldw	r4,-32692(gp)
    3114:	2000021e 	bne	r4,zero,3120 <main+0x28>
         {
            // jtag_uart test
            c = jtag_uart_getch();
    3118:	00028800 	call	2880 <jtag_uart_getch>
    311c:	00000606 	br	3138 <main+0x40>
         }
         else if (io_stream == 1)
    3120:	00800044 	movi	r2,1
    3124:	2080021e 	bne	r4,r2,3130 <main+0x38>
         {
            // rs232_uart test
            c = rs232_uart_getch();
    3128:	000295c0 	call	295c <rs232_uart_getch>
    312c:	00000206 	br	3138 <main+0x40>
         }
         else
         {
            // eth test
            c = eth_getch(io_stream - 2);
    3130:	213fff84 	addi	r4,r4,-2
    3134:	00026700 	call	2670 <eth_getch>
    3138:	1021883a 	mov	r16,r2
         }
         //
         if (c < 0)
    313c:	1000070e 	bge	r2,zero,315c <main+0x64>
         {
            // current io_stream not ready: switch to next
            io_stream++;
    3140:	d0a01317 	ldw	r2,-32692(gp)
            if (io_stream > 9)
    3144:	00c00244 	movi	r3,9
    3148:	10800044 	addi	r2,r2,1
    314c:	d0a01315 	stw	r2,-32692(gp)
    3150:	1880580e 	bge	r3,r2,32b4 <main+0x1bc>
               io_stream = 0;
    3154:	d0201315 	stw	zero,-32692(gp)
    3158:	00005606 	br	32b4 <main+0x1bc>
            // line-parser-FSM restarts
            sts = 0;
         }
      } while (c < 0);

      // echo to current io_stream
      output_putchar(c);
    315c:	1009883a 	mov	r4,r2
    3160:	0002a500 	call	2a50 <output_putchar>

      // blank filter
      blank = 0;
      if ((c == 0) || (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r'))
    3164:	800d003a 	cmpeq	r6,r16,zero
    3168:	0009883a 	mov	r4,zero
    316c:	3000081e 	bne	r6,zero,3190 <main+0x98>
    3170:	00800804 	movi	r2,32
    3174:	80800626 	beq	r16,r2,3190 <main+0x98>
    3178:	00800244 	movi	r2,9
    317c:	80800426 	beq	r16,r2,3190 <main+0x98>
    3180:	00800284 	movi	r2,10
    3184:	80800226 	beq	r16,r2,3190 <main+0x98>
    3188:	00800344 	movi	r2,13
    318c:	8080011e 	bne	r16,r2,3194 <main+0x9c>
      {
         blank = 1;
    3190:	01000044 	movi	r4,1
         // note: eol ('\n' or '\r') mapped as blank char
      }

      // line-parser-FSM
      switch (sts)
    3194:	d0e01417 	ldw	r3,-32688(gp)
    3198:	01400044 	movi	r5,1
    319c:	19400e26 	beq	r3,r5,31d8 <main+0xe0>
    31a0:	28c00216 	blt	r5,r3,31ac <main+0xb4>
    31a4:	18000626 	beq	r3,zero,31c0 <main+0xc8>
    31a8:	00003c06 	br	329c <main+0x1a4>
    31ac:	00800084 	movi	r2,2
    31b0:	18801126 	beq	r3,r2,31f8 <main+0x100>
    31b4:	008000c4 	movi	r2,3
    31b8:	18801526 	beq	r3,r2,3210 <main+0x118>
    31bc:	00003706 	br	329c <main+0x1a4>
      {
      case 0:
         // cmd0
         cmd0 = 0;
         if (!blank)
    31c0:	2004c03a 	cmpne	r2,r4,zero
    31c4:	d0201915 	stw	zero,-32668(gp)
    31c8:	1000341e 	bne	r2,zero,329c <main+0x1a4>
         {
            cmd0 = c;
            sts = 1;
    31cc:	d1601415 	stw	r5,-32688(gp)
    31d0:	d4201915 	stw	r16,-32668(gp)
         }
         break;
    31d4:	00003106 	br	329c <main+0x1a4>

      case 1:
         // cmd1
         if (!blank)
    31d8:	2004c03a 	cmpne	r2,r4,zero
    31dc:	1000041e 	bne	r2,zero,31f0 <main+0xf8>
         {
            cmd1 = c;
            sts = 2;
    31e0:	00800084 	movi	r2,2
    31e4:	d0a01415 	stw	r2,-32688(gp)
    31e8:	d4201a15 	stw	r16,-32664(gp)
    31ec:	00002b06 	br	329c <main+0x1a4>
         }
         else
         {
            // single char command detected
            sts = 99 + 0;
    31f0:	008018c4 	movi	r2,99
    31f4:	00002806 	br	3298 <main+0x1a0>
         }
         break;

      case 2:
         // blank check
         if (blank)
         {
            narg = 0;
            dat = 0;
            argflag = 0;
            sts = 3;
         }
         else
         {
            // command with 3 or more consecutive chars detected
            sts = 99 + 1;
    31f8:	00801904 	movi	r2,100
    31fc:	20002626 	beq	r4,zero,3298 <main+0x1a0>
    3200:	008000c4 	movi	r2,3
    3204:	d0a01415 	stw	r2,-32688(gp)
    3208:	d0201615 	stw	zero,-32680(gp)
    320c:	00000d06 	br	3244 <main+0x14c>
         }
         break;

      case 3:
         // 2 chars standard command: arg0..N decoded
         if (blank)
    3210:	20000f26 	beq	r4,zero,3250 <main+0x158>
         {
            if (argflag == 0)
    3214:	d0a01517 	ldw	r2,-32684(gp)
    3218:	10002026 	beq	r2,zero,329c <main+0x1a4>
            {
               // extra blank ignored
            }
            else if (narg < sizeof(arg)/sizeof(arg[0]))
    321c:	d1201617 	ldw	r4,-32680(gp)
    3220:	19001e36 	bltu	r3,r4,329c <main+0x1a4>
            {
               arg[narg] = dat;
    3224:	200690ba 	slli	r3,r4,2
    3228:	00800034 	movhi	r2,0
    322c:	108d9d04 	addi	r2,r2,13940
               narg++;
    3230:	21000044 	addi	r4,r4,1
    3234:	1887883a 	add	r3,r3,r2
    3238:	d0a01717 	ldw	r2,-32676(gp)
    323c:	d1201615 	stw	r4,-32680(gp)
    3240:	18800015 	stw	r2,0(r3)
               dat = 0;
    3244:	d0201715 	stw	zero,-32676(gp)
               argflag = 0;
    3248:	d0201515 	stw	zero,-32684(gp)
    324c:	00001306 	br	329c <main+0x1a4>
            }
         }
         else if (((c >= '0') && (c <= '9')))
    3250:	80fff404 	addi	r3,r16,-48
    3254:	00800244 	movi	r2,9
    3258:	10c0082e 	bgeu	r2,r3,327c <main+0x184>
         {
            dat = (dat << 4) | (c - '0');
            argflag = 1;
         }
         else if ((c >= 'A') && (c <= 'F'))
    325c:	80bfefc4 	addi	r2,r16,-65
    3260:	00c00144 	movi	r3,5
    3264:	18800236 	bltu	r3,r2,3270 <main+0x178>
         {
            dat = (dat << 4) | (c - 'A' + 10);
    3268:	80fff244 	addi	r3,r16,-55
    326c:	00000306 	br	327c <main+0x184>
            argflag = 1;
         }
         else if ((c >= 'a') && (c <= 'f'))
    3270:	80bfe7c4 	addi	r2,r16,-97
    3274:	18800736 	bltu	r3,r2,3294 <main+0x19c>
         {
            dat = (dat << 4) | (c - 'a' + 10);
    3278:	80ffea44 	addi	r3,r16,-87
    327c:	d0a01717 	ldw	r2,-32676(gp)
            argflag = 1;
    3280:	d1601515 	stw	r5,-32684(gp)
    3284:	1004913a 	slli	r2,r2,4
    3288:	10c4b03a 	or	r2,r2,r3
    328c:	d0a01715 	stw	r2,-32676(gp)
    3290:	00000206 	br	329c <main+0x1a4>
         }
         else
         {
            // invalid char on args: command line error signaled
            sts = 99 + 2;
    3294:	00801944 	movi	r2,101
    3298:	d0a01415 	stw	r2,-32688(gp)
         }
         break;

      default:
         // error: line-parser-FSM stops (next 'cmdexec()' will decode errors)
         break;
      }

      // command exec when eol
      if (c == 0 || c == '\n' || c == '\r')
    329c:	3000041e 	bne	r6,zero,32b0 <main+0x1b8>
    32a0:	00800284 	movi	r2,10
    32a4:	80800226 	beq	r16,r2,32b0 <main+0x1b8>
    32a8:	00800344 	movi	r2,13
    32ac:	80bf971e 	bne	r16,r2,310c <main+0x14>
      {
         // command exec
         cmdexec();
    32b0:	0002fe40 	call	2fe4 <cmdexec>
         // line-parser-FSM restarts
         sts = 0;
    32b4:	d0201415 	stw	zero,-32688(gp)
    32b8:	003f9406 	br	310c <main+0x14>

000032bc <__mulsi3>:
    32bc:	0007883a 	mov	r3,zero
    32c0:	20000626 	beq	r4,zero,32dc <__mulsi3+0x20>
    32c4:	2080004c 	andi	r2,r4,1
    32c8:	2008d07a 	srli	r4,r4,1
    32cc:	10000126 	beq	r2,zero,32d4 <__mulsi3+0x18>
    32d0:	1947883a 	add	r3,r3,r5
    32d4:	294b883a 	add	r5,r5,r5
    32d8:	203ffa1e 	bne	r4,zero,32c4 <__mulsi3+0x8>
    32dc:	1805883a 	mov	r2,r3
    32e0:	f800283a 	ret

000032e4 <alt_main>:
 * the users application, i.e. main().
 */

void alt_main (void)
{
    32e4:	deffff04 	addi	sp,sp,-4
  int result;

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    32e8:	0009883a 	mov	r4,zero
    32ec:	dfc00015 	stw	ra,0(sp)
    32f0:	00033180 	call	3318 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();

  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    32f4:	00033380 	call	3338 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");

#if !defined(ALT_USE_DIRECT_DRIVERS) && (defined(ALT_STDIN_PRESENT) || defined(ALT_STDOUT_PRESENT) || defined(ALT_STDERR_PRESENT))

  /*
   * Redirect stdio to the apropriate devices now that the devices have
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
#endif

#ifndef ALT_NO_C_PLUS_PLUS
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
#endif /* ALT_NO_C_PLUS_PLUS */

#if !defined(ALT_NO_C_PLUS_PLUS) && !defined(ALT_NO_CLEAN_EXIT) && !defined(ALT_NO_EXIT)
  /*
   * Set the C++ destructors to be called at system shutdown. This is only done
   * if a clean exit has been requested (i.e. the exit() function has not been
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
#endif

  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    32f8:	d1200217 	ldw	r4,-32760(gp)
    32fc:	d1600117 	ldw	r5,-32764(gp)
    3300:	d1a00017 	ldw	r6,-32768(gp)
    3304:	02000034 	movhi	r8,0
    3308:	420c3e04 	addi	r8,r8,12536
    330c:	dfc00017 	ldw	ra,0(sp)
    3310:	dec00104 	addi	sp,sp,4
    3314:	4000683a 	jmp	r8

00003318 <alt_irq_init>:
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    3318:	deffff04 	addi	sp,sp,-4
    331c:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_IRQ_INIT ( CPU, cpu);
    3320:	00034140 	call	3414 <altera_nios2_irq_init>
    3324:	00800044 	movi	r2,1
    3328:	1001703a 	wrctl	status,r2
    332c:	dfc00017 	ldw	ra,0(sp)
    3330:	dec00104 	addi	sp,sp,4
    3334:	f800283a 	ret

00003338 <alt_sys_init>:
    alt_irq_cpu_enable_interrupts();
}

/*
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
}
    3338:	f800283a 	ret

0000333c <altera_avalon_jtag_uart_read>:
{
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;
    333c:	2993883a 	add	r9,r5,r6
    3340:	21000017 	ldw	r4,0(r4)
    3344:	2807883a 	mov	r3,r5

  while (ptr < end)
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
      break;   
    3348:	2a400b2e 	bgeu	r5,r9,3378 <altera_avalon_jtag_uart_read+0x3c>
    334c:	3890000c 	andi	r2,r7,16384
    3350:	1011003a 	cmpeq	r8,r2,zero
    3354:	21800037 	ldwio	r6,0(r4)
    3358:	30a0000c 	andi	r2,r6,32768
    335c:	10000326 	beq	r2,zero,336c <altera_avalon_jtag_uart_read+0x30>
    3360:	19800005 	stb	r6,0(r3)
    3364:	18c00044 	addi	r3,r3,1
    3368:	00000206 	br	3374 <altera_avalon_jtag_uart_read+0x38>
    336c:	1940031e 	bne	r3,r5,337c <altera_avalon_jtag_uart_read+0x40>
    3370:	40000126 	beq	r8,zero,3378 <altera_avalon_jtag_uart_read+0x3c>
    3374:	1a7ff736 	bltu	r3,r9,3354 <altera_avalon_jtag_uart_read+0x18>
    
  }

  if (ptr != buffer)
    3378:	19400226 	beq	r3,r5,3384 <altera_avalon_jtag_uart_read+0x48>
    return ptr - buffer;
    337c:	1947c83a 	sub	r3,r3,r5
    3380:	00000406 	br	3394 <altera_avalon_jtag_uart_read+0x58>
  else if (flags & O_NONBLOCK)
    3384:	3890000c 	andi	r2,r7,16384
    return -EWOULDBLOCK;
    3388:	00fffd44 	movi	r3,-11
    338c:	1000011e 	bne	r2,zero,3394 <altera_avalon_jtag_uart_read+0x58>
  else
    return -EIO;
    3390:	00fffec4 	movi	r3,-5
}
    3394:	1805883a 	mov	r2,r3
    3398:	f800283a 	ret

0000339c <altera_avalon_uart_read>:
{
  int block;
  unsigned int status;

  block = !(flags & O_NONBLOCK);
    339c:	380ed3ba 	srli	r7,r7,14
    33a0:	deffff04 	addi	sp,sp,-4
    33a4:	dfc00015 	stw	ra,0(sp)
    33a8:	39c0004c 	andi	r7,r7,1

  do
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
    33ac:	20800017 	ldw	r2,0(r4)
    33b0:	10800204 	addi	r2,r2,8
    33b4:	10c00037 	ldwio	r3,0(r2)

    /* clear any error flags */

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);
    33b8:	10000035 	stwio	zero,0(r2)

    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
    33bc:	1880200c 	andi	r2,r3,128
    33c0:	10000526 	beq	r2,zero,33d8 <altera_avalon_uart_read+0x3c>
    {
      ptr[0] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
    33c4:	20800017 	ldw	r2,0(r4)
    33c8:	10800037 	ldwio	r2,0(r2)

      if (!(status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
    33cc:	18c000cc 	andi	r3,r3,3
    33d0:	28800005 	stb	r2,0(r5)
    33d4:	18000726 	beq	r3,zero,33f4 <altera_avalon_uart_read+0x58>
      ALTERA_AVALON_UART_STATUS_FE_MSK)))
      {
        return 1;
      }
    }
  }
    33d8:	383ff426 	beq	r7,zero,33ac <altera_avalon_uart_read+0x10>
    33dc:	d0a00517 	ldw	r2,-32748(gp)
    33e0:	d0e02304 	addi	r3,gp,-32628
    33e4:	10000526 	beq	r2,zero,33fc <altera_avalon_uart_read+0x60>
    33e8:	103ee83a 	callr	r2
    33ec:	1007883a 	mov	r3,r2
    33f0:	00000206 	br	33fc <altera_avalon_uart_read+0x60>
    33f4:	00800044 	movi	r2,1
    33f8:	00000306 	br	3408 <altera_avalon_uart_read+0x6c>
    33fc:	008002c4 	movi	r2,11
    3400:	18800015 	stw	r2,0(r3)
  while (block);

  ALT_ERRNO = EWOULDBLOCK;
 
  return 0;
    3404:	0005883a 	mov	r2,zero
}
    3408:	dfc00017 	ldw	ra,0(sp)
    340c:	dec00104 	addi	sp,sp,4
    3410:	f800283a 	ret

00003414 <altera_nios2_irq_init>:
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    3414:	000170fa 	wrctl	ienable,zero
    3418:	f800283a 	ret
